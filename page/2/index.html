<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="有间栈">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="有间栈">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fremont">
<meta property="article:tag" content="Java, Spring Boot, 算法，编程技术">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>有间栈</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">有间栈</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fremont</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/08/%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fremont">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="有间栈">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 有间栈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/08/%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">并发常见问题-历史学习记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-08 22:38:11 / 修改时间：22:43:24" itemprop="dateCreated datePublished" datetime="2025-06-08T22:38:11+08:00">2025-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">历史学习记录</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>54 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-什么是线程？"><a href="#1-什么是线程？" class="headerlink" title="1. 什么是线程？"></a>1. 什么是线程？</h2><ol>
<li>现代操作系统在运行一个程序时，会为其创建一个进程。</li>
<li>而线程是现代操作系统进行资源调度的基本单元，也叫轻量级进程，在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上告诉切换，让使用者感受到这些线程在同时执行。</li>
</ol>
<h2 id="2-java线程间通信"><a href="#2-java线程间通信" class="headerlink" title="2. java线程间通信"></a>2. java线程间通信</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. volatile和synchronized关键字</span><br><span class="line">2. 等待/通知机制</span><br><span class="line">3. 管道输入/输出流</span><br><span class="line">4. Thread.join()的使用</span><br><span class="line">5. ThreadLocal的使用</span><br></pre></td></tr></table></figure>
<ol>
<li><p>volatile和synchronized关键字  </p>
<ul>
<li>本质上是通过共享内存的方式实现线程通信：  <ol>
<li>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何堆该变量的访问都需从共享内存中获取，而且对它的改变需要立刻刷新回共享内存。它能保证所有线程对volatile修饰的变量的可见性。</li>
<li>关键字synchronized用来修饰方法或者以同步块的形式使用。它保主要确保在同一个时刻，只能有一个线程处于方法或同步块中，保证了线程对变量访问的可见性和排他性。  <ol>
<li>具体实现本质上是对一个对象的监视器进行获取，而这个获取的过程是排他的，也就是同一个时刻只能有一个线程获取到由synchronized所保护对象的监视器。</li>
<li>任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获得该对象的监视器才能进入同步块或同步方法，而没有获取到监视器的线程将会被阻塞在同步块或同步方法的入口处。</li>
<li>任意线程对Object（Object由synchronized保护）的访问，首先要获得Object的监视器。如果获取失败，线程进入同步队列，线程状态变为BLOCKED。当访问Object的前驱释放了锁，则该释放动作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取。</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li><p>等待&#x2F;通知机制  </p>
<ul>
<li>本质上是生产者和消费者模式，这种模式隔离了做什么和怎么做，在功能层面上实现了解耦。  </li>
<li>等待通知的相关方法是任意Java对象都具备的，因为这些方法被定义在所有对象的超类<code>java.lang.Object</code>上；通过<code>wait()</code>,<code>notify()</code>,<code>notifyAll()</code>来实现。    <ol>
<li>等待&#x2F;通知机制，是指一个线程A调用了对象O的<code>wait()</code>方法进入等待状态，而另一个线程B调用了对象O的<code>notify()</code>或<code>notifyAll()</code>方法，线程A收到通知后从<code>wait()</code>方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互。</li>
<li>调用<code>wait()</code>,<code>notify()</code>,<code>notifyAll()</code>需要注意的细节：  <ol>
<li>使用<code>wait()</code>,<code>notify()</code>,<code>notifyAll()</code>方法前，需要先对调用对象加锁；</li>
<li>调用<code>wait()</code>方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列；</li>
<li><code>notify()</code>和<code>notifyAll()</code>方法调用后，等待线程依旧不会从<code>wait()</code>方法返回，需要调用<code>notify()</code>和<code>notifyAll()</code>的线程释放锁之后，等待线程才有机会从<code>wait()</code>返回；</li>
<li><code>notify()</code>方法将等待队列中的一个线程从等待队列中移到同步队列中，而<code>notifyAll()</code>方法将等待队列中的所有线程全部从等待队列中移到同步队列，被移动的线程状态由WAITING变为BLOCKED;</li>
<li>从<code>wait()</code>方法返回的前提是获得了调用对象的锁；</li>
</ol>
</li>
</ol>
</li>
<li>等待&#x2F;通知机制依托于同步机制，其目的就是确保等待线程从<code>wait()</code>方法返回时能够感知到通知线程对变量做出的修改；</li>
<li><code>WaitThread</code>首先获取了对象的锁，然后调用对象的<code>wait()</code>方法，从而放弃了锁进入了对象的等待队列WaitQueue中，进入等待状态。由于WaitThread释放了对象的锁，NntifyThread随后获取了对象的锁，并调用对象的<code>notify()</code>方法，将WaitThread从WaitQueue移到SynchronizedQueue中，此时WaitThread的状态变为阻塞状态。NotifyThread释放了锁之后，WaitThread再次获取到锁并从<code>wait()</code>方法返回继续执行；</li>
</ul>
</li>
<li><p>管道输入&#x2F;输出流  </p>
<ul>
<li>管道输入&#x2F;输出流和普通文件输入&#x2F;输出流或者网络输入&#x2F;输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存；</li>
<li>管道输入&#x2F;输出流主要包括如下4中具体实现：前两种面向字节，而后两种面向字符。<ol>
<li><code>PipedOutputStream</code>:</li>
<li><code>PipedInputStream</code></li>
<li><code>PipedReader</code></li>
<li><code>PipedWriter</code></li>
</ol>
</li>
<li>对于Piped类型的流，必须要先进行绑定，也就是调用<code>connect()</code>方法，如果没有将输入&#x2F;输出流绑定起来，对于该流的访问将会抛出异常；</li>
</ul>
</li>
<li><p><code>Thread.join()</code>的使用</p>
<ul>
<li>是主线程等待子线程的终止。也就是说主线程的代码块中，如果碰到了<code>t.join()</code>方法，此时主线程需要等待（阻塞），等待子线程结束了(Waits for this thread to die.),才能继续执行<code>t.join()</code>之后的代码块。</li>
</ul>
</li>
<li><p><code>ThreadLocal</code>的使用</p>
<ul>
<li>即线程变量，是一个以Thread对象为键，任意对象为值的存储结构。这个结构被附带在线程上，也就是一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</li>
</ul>
</li>
</ol>
<h2 id="3-多线程共享数据"><a href="#3-多线程共享数据" class="headerlink" title="3. 多线程共享数据"></a>3. 多线程共享数据</h2><ol>
<li>如果每个线程执行的代码相同，可以使用同一个Runnable对象，这个Runnable对象中有那个共享数据，例如，买票系统就可以这么做。 </li>
<li>如果每个线程执行的代码不同，这时候需要用不同的Runnable对象，有如下两种方式来实现这些Runnable对象之间的数据共享： <ul>
<li>将共享数据封装在另外一个对象中，然后将这个对象逐一传递给各个Runnable对象。每个线程对共享数据的操作方法也分配到那个对象身上去完成，这样容易实现针对该数据进行的各个操作的互斥和通信。</li>
<li>将这些Runnable对象作为某一个类中的内部类，共享数据作为这个外部类中的成员变量，每个线程对共享数据的操作方法也分配给外部类，以便实现对共享数据进行的各个操作的互斥和通信，作为内部类的各个Runnable对象调用外部类的这些方法。</li>
</ul>
</li>
</ol>
<h2 id="4-信号量和互斥量的区别"><a href="#4-信号量和互斥量的区别" class="headerlink" title="4. 信号量和互斥量的区别"></a>4. 信号量和互斥量的区别</h2><ol>
<li>互斥用于线程的互斥，信号量用于线程的同步<ul>
<li>这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。</li>
<li>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</li>
<li>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源</li>
</ul>
</li>
<li>互斥量只能是0&#x2F;1，信号量可以是任何非负整数<ul>
<li>一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。</li>
</ul>
</li>
<li>互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</li>
</ol>
<h2 id="5-线程是怎么实现的-线程有哪些方法？Wait-是线程的方法吗？"><a href="#5-线程是怎么实现的-线程有哪些方法？Wait-是线程的方法吗？" class="headerlink" title="5. 线程是怎么实现的 线程有哪些方法？Wait()是线程的方法吗？"></a>5. 线程是怎么实现的 线程有哪些方法？Wait()是线程的方法吗？</h2><h3 id="5-1-多线程实现的四种方法"><a href="#5-1-多线程实现的四种方法" class="headerlink" title="5.1 多线程实现的四种方法"></a>5.1 多线程实现的四种方法</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duanjiapingjy/p/9434244.html">csdn线程实现</a></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 继承`Thread`类，重写run方法（因为Thread本身也实现了Runnable接口）</span><br><span class="line">2. 实现`Runnable`接口，重写`run`方法</span><br><span class="line">3. 实现`Callable`接口，重写call方法（**有返回值**）</span><br><span class="line">4. 使用线程池（**有返回值**）</span><br></pre></td></tr></table></figure>

<ol>
<li>继承<code>Thread</code>类，重写run方法:<ul>
<li>每次新建一个线程，都要新建一个<code>Thread</code>子类的对象；</li>
<li>启动线程，<code>new Thread子类().start()</code>；</li>
<li>创建线程实际上调用的是父类<code>Thread</code>空参的构造器；</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ards[])</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">ExtendsThread</span>().start();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExtendsThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>实现<code>Runnable</code>接口，重写<code>run</code>方法：<ul>
<li>不管创建多少线程，都只需要一个<code>Runnable</code>接口实现类的对象；</li>
<li>启动线程，<code>new Thread(Runnable接口实现类).start()</code>；</li>
<li>创建线程实际上调用的是父类<code>Thread</code>类<code>Runnable</code>类型参数的构造器；</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ards[])</span>&#123;</span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">implRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImplRunnable</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Thread</span>(implRunnable).start();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImplRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span>  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&quot;</span>+ i++);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>实现实现<code>Callable</code>接口，重写call方法<ul>
<li>自定义类实现Callable接口时，必须指定泛型，该泛型即返回值的类型</li>
<li>每次创建一个新的线程，都要创建一个新的Callable接口的实现类、</li>
<li>如何启动线程？<ol>
<li>创建一个Callable接口的实现类的对象</li>
<li>创建一个FutureTask对象，传入Callable类型的参数。<code>public FutureTask(Callable&lt;V&gt; callable)&#123;……&#125;</code></li>
<li>调用Thread类重载的参数为Runnable的构造器创建Thread对象，将FutureTask作为参数传递<ul>
<li><code>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</code></li>
<li><code>public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;</code></li>
</ul>
</li>
</ol>
</li>
<li>如何获取返回值？<ol>
<li>调用FutureTask类的get()方法</li>
</ol>
</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ards[])</span> <span class="keyword">throws</span> InterruptedException, ExecutionException&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">			Callable&lt;Integer&gt; implCallable = <span class="keyword">new</span> <span class="title class_">ImplCallable</span>();</span><br><span class="line">			FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(implCallable);</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;----&quot;</span>+futureTask.get());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImplCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">			result += i;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName());</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>线程池<ul>
<li><code>Executor</code>类</li>
</ul>
</li>
</ol>
<h2 id="6-线程实现各有什么优缺点？"><a href="#6-线程实现各有什么优缺点？" class="headerlink" title="6. 线程实现各有什么优缺点？"></a>6. 线程实现各有什么优缺点？</h2><ol>
<li><p>继承Thread类：</p>
<ul>
<li>Java是单继承， 继承Thread类之后无法再继承其他类</li>
<li>需要为每个需要线程执行的方法单独创建一个class文件，开发效率较低</li>
<li>没有返回值</li>
<li>一般不推荐使用</li>
<li>但编写简单，直接使用<code>this</code>就可以获得当前线程；</li>
</ul>
</li>
<li><p>实现Runnable和Callable接口方式：</p>
<ul>
<li>优点：<ol>
<li>线程类只是实现了Runnable接口（JDK1.0开始）或Callable接口（JDK1.5开始），还可以继承其他类。</li>
<li>多线程可以共享同一个target对象，非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
<li>实现Callable接口创建多线程最大的好处是可以有返回值。</li>
</ol>
</li>
<li>缺点：<ol>
<li>编程稍显复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="7-wait和sleep的区别和联系"><a href="#7-wait和sleep的区别和联系" class="headerlink" title="7. wait和sleep的区别和联系"></a>7. wait和sleep的区别和联系</h2><ol>
<li><code>sleep()</code>没有释放锁，<code>wait()</code>释放锁；</li>
<li>两者都可以暂停线程；</li>
<li><code>wait()</code>方法被用于线程间的通信&#x2F;交互，<code>sleep()</code>方法用于暂停线程；</li>
<li><code>wait()</code>方法被调用后，除非使用<code>wait(long timeout)</code>，超时后线程自动苏醒，否则线程不会自动苏醒，需要别的线程调用同一对象上的<code>notify()</code>或<code>notifyAll()</code>方法。而<code>sleep()</code>方法执行完后，线程会自动苏醒。</li>
</ol>
<h2 id="8-要用start-方法区执行run-方法而不是直接调用run-方法"><a href="#8-要用start-方法区执行run-方法而不是直接调用run-方法" class="headerlink" title="8. 要用start()方法区执行run()方法而不是直接调用run()方法"></a>8. 要用start()方法区执行run()方法而不是直接调用run()方法</h2><blockquote>
<p>new一个Thread会使线程进入新建状态，然后调用线程的<code>start()</code>方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后，就可以开始运行了。<code>start()</code>会执行线程相应的准备工作，然后自动执行<code>run()</code>方法的内容，这是真正的多线程工作。但是，直接执行<code>run()</code>方法，会把<code>run()</code>方法当作<code>main</code>线程下的一个普通方法来执行，并不会在某个线程中执行它，所有这并不是多线程工作。</p>
</blockquote>
<h2 id="9-线程有几种状态-上下文切换"><a href="#9-线程有几种状态-上下文切换" class="headerlink" title="9. 线程有几种状态 上下文切换"></a>9. 线程有几种状态 上下文切换</h2><ol>
<li>NEW：			初始状态，线程被构建，但还没调用<code>start()</code>方法；</li>
<li>RUNNABLE:   		运行状态，Java线程将操作系统中的就绪和运行两种状态统称为“运行状态”；</li>
<li>BLOCKED：  		阻塞状态，标识线程阻塞于锁；</li>
<li>WAITING:     	等待状态，该状态标识线程已经获得锁，但需要当前线程需要等待其他线程做出一些特定动作（如通知或中断）</li>
<li>TIME_WAITING:  	超时等待，可以在指定的时间自行返回；</li>
<li>TERMINATED:      终止状态，表示当前线程已经执行完毕；</li>
</ol>
<ul>
<li><p>总结：  </p>
<ol>
<li>线程创建后，调用<code>start()</code>方法开始运行。</li>
<li>当线程执行<code>wait()</code>方法之后，线程进入等待状态。进入等待状态的线程需要依靠其他现成的通知才能够返回到运行状态；而超时等待状态相当于在等待状态的基础上增加了超时限制，也就是超时时间到达时将会返回到运行状态。</li>
<li>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入阻塞状态；</li>
<li>当线程运行Runnable的<code>run()</code>方法之后将会进入到终止状态。</li>
</ol>
</li>
<li><p>上下文切换：  </p>
<ol>
<li>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载就是一次上下文切换。</li>
</ol>
</li>
<li><p>如何减少上下文的开销：  </p>
<ol>
<li>无锁并发编程；</li>
<li>CAS算法</li>
<li>使用最少线程</li>
<li>协程</li>
</ol>
</li>
</ul>
<h2 id="10-ThreadLocal"><a href="#10-ThreadLocal" class="headerlink" title="10. ThreadLocal"></a>10. ThreadLocal</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fsmly/p/11020641.html">ThreadLocal详解</a> </p>
<h3 id="10-1-ThreadLocal简介"><a href="#10-1-ThreadLocal简介" class="headerlink" title="10.1 ThreadLocal简介"></a>10.1 ThreadLocal简介</h3><blockquote>
<p>多线程访问同一个共享变量的时候容易出现并发问题，特别是多个线程对一个变量进行写入的时候，为了保证线程安全，一般使用者在访问共享变量的时候需要进行额外的同步措施才能保证线程安全性。ThreadLocal是除了加锁这种同步方式之外的一种保证一种规避多线程访问出现线程不安全的方法，当我们在创建一个变量后，如果每个线程对其进行访问的时候访问的都是线程自己的变量这样就不会存在线程不安全问题。<br>ThreadLocal是JDK包提供的，它提供线程本地变量，如果创建一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的一个副本，在实际多线程操作的时候，操作的是自己本地内存中的变量，从而规避了线程安全问题。</p>
</blockquote>
<ol>
<li><code>ThreadLocal</code>，即线程变量，是一个以<code>ThreadLocal</code>对象为键、任意对象为值的存储结构。</li>
<li>这个结构被附带再线程上，也就是说一个线程可以根据一个<code>Thread</code>对象查询到绑定在这个线程上的一个值。</li>
<li>比如可以通过<code>set(T)</code>方法来设置一个值，在当前线程下再通过<code>get()</code>方法获取到原先设置的值。</li>
</ol>
<h3 id="10-2-ThreadLocal的实现原理"><a href="#10-2-ThreadLocal的实现原理" class="headerlink" title="10.2 ThreadLocal的实现原理"></a>10.2 ThreadLocal的实现原理</h3><blockquote>
<p><code>Thread</code>类中有一个<code>threadLocals</code>和<code>inheritableThreadLocals</code>变量，它们都是<code>ThreadLocalMap</code>类型的变量，可以把<code>ThreadLocalMap</code>变量理解成一个为<code>ThreadLocal</code>类实现而定制化的<code>HashMap</code>。默认情况下，每个线程的这两个变量都为<code>null</code>，只有当线程第一次调用<code>ThreadLocal</code>类的<code>set()</code>或<code>get()</code>方法时才会创建他们。</p>
</blockquote>
<ol>
<li><p><code>set()</code>方法源码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">	<span class="comment">//(1)获取当前线程（调用者线程）</span></span><br><span class="line">	<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">	<span class="comment">//(2)以当前线程作为key值，去查找对应的线程变量，找到对应的map</span></span><br><span class="line">	<span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">	<span class="comment">//(3)如果map不为null，就直接添加本地变量，key为当前线程，值为添加的本地变量值</span></span><br><span class="line">	<span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">		map.set(<span class="built_in">this</span>, value);</span><br><span class="line">	<span class="comment">//(4)如果map为null，说明首次添加，需要首先创建出对应的map</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> t.threadLocals; <span class="comment">//获取线程自己的变量threadLocals，并绑定到当前调用线程的成员变量threadLocals上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//createMap方法不仅创建了threadLocals，同时也将要添加的本地变量值添加到了threadLocals中。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">	t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>get()</code>方法源码：</p>
<blockquote>
<p><code>get()</code>方法首先获取当前线程，<code>getMap()</code>方法获取当前线程的<code>ThreadLocal</code>对象，如果不为null，就返回当前线程绑定的本地变量值；否则执行<code>setInitialValue()</code>方法初始化<code>ThreadLocals</code>变量。</p>
</blockquote>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value in the current thread&#x27;s copy of this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment"> * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment"> * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current thread&#x27;s value of this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>remove()</code>方法：</p>
<blockquote>
<p>remove方法判断该当前线程对应的threadLocals变量是否为null，不为null就直接删除当前线程中指定的threadLocals变量</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>) &#123;</span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p><strong>总结</strong>：每个线程内部都有一个<code>threadLocals</code>的成员变量，该变量的类型是<code>ThreadLocal.ThreadLocalMap</code>类型（类似于一个HashMap），其中的<code>key</code>是当前定义的Thread变量的this引用，<code>value</code>是<code>set()</code>方法设置的值。<strong>每个线程的本地变量存放在自己的本地内存变量<code>threadLocals</code>中，如果当前线程一直不消亡，那么这些本地变量就会一直存在，可能导致内存溢出，因此使用完毕需要将其<code>remove</code>掉。</strong></p>
</li>
</ol>
<h3 id="10-3-ThreadLocal内存泄漏问题"><a href="#10-3-ThreadLocal内存泄漏问题" class="headerlink" title="10.3 ThreadLocal内存泄漏问题"></a>10.3 ThreadLocal内存泄漏问题</h3><blockquote>
<p><code>ThreadLocalMap</code>中使用的 <code>key</code>被传递给了<code>WeakReference</code>的构造函数，所以<code>key</code>为 <code>ThreadLocal</code> 的弱引用,而<code>value</code>是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法.  </p>
</blockquote>
<h2 id="11-就绪状态和阻塞状态有什么区别-两者可以互相切换吗"><a href="#11-就绪状态和阻塞状态有什么区别-两者可以互相切换吗" class="headerlink" title="11. 就绪状态和阻塞状态有什么区别  两者可以互相切换吗"></a>11. 就绪状态和阻塞状态有什么区别  两者可以互相切换吗</h2><p>Java中就绪和运行两种状态统称为Runnable状态。  </p>
<p>但在常规线程中（比如操作系统中的线程），就绪状态是指，在线程被创建后，其他线程中调用了该线程的<code>start()</code>方法。就绪状态的线程位于“可运行线程池中”，运行的所有其他条件都满足，只等待获取cpu的使用权（时间片）。也即是，就绪状态的线程除了cpu分配的时间片外，其他的运行所需资源已经全部满足。  </p>
<p>阻塞状态是线程因为某种原因而放弃了cpu的使用权，暂时停止运行。直到线程进入就绪状态，才有机会转换到运行状态。阻塞状态分三种：  </p>
<ol>
<li>等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒，</li>
<li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。</li>
<li>其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I&#x2F;O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入就绪状态。</li>
</ol>
<h2 id="12-进程和线程切换开销对比"><a href="#12-进程和线程切换开销对比" class="headerlink" title="12. 进程和线程切换开销对比"></a>12. 进程和线程切换开销对比</h2><ol>
<li>进程切换开销<ul>
<li>切换虚拟地址空间</li>
<li>切换CPU上下文</li>
<li>切换内核栈</li>
</ul>
</li>
<li>线程切换开销<ul>
<li>切换CPU上下文</li>
<li>切换内核栈</li>
</ul>
</li>
</ol>
<h2 id="13-Java中的锁"><a href="#13-Java中的锁" class="headerlink" title="13. Java中的锁"></a>13. Java中的锁</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jyroy/p/11365935.html">Java锁</a><br><img src="/./image/%E9%94%81.png" alt="锁"></p>
<h2 id="14-CAS的含义-ABA问题"><a href="#14-CAS的含义-ABA问题" class="headerlink" title="14. CAS的含义 ABA问题"></a>14. CAS的含义 ABA问题</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bjweimengshu/article/details/78949435?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160851567016780302998169%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&request_id=160851567016780302998169&biz_id=0">这个人的CAS讲的很好，还有其他博客可以看看</a> </p>
<blockquote>
<p>compare and swap,CAS操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。   </p>
</blockquote>
<ol>
<li>CAS底层是通过<code>unsafe</code>类的<code>compareandSwap</code>方法实现的；<code>compareandSwap</code>有四个参数，分别是要修改的对象、对象中要修改变量的偏移量（可理解为要修改变量的内存地址）、修改之前的旧值、要修改的新值；  </li>
<li>CAS机制包括三个基本操作数：内存地址V、旧的预期值A、要修改的新值B，更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B；  </li>
<li>CAS缺点：<ul>
<li>CPU开销大</li>
<li>不能保证代码块的原子性</li>
<li>ABA问题：<ol>
<li>当一个值从A更新成B，又更新会A，普通CAS机制会误判通过检测。</li>
<li>利用版本号比较可以有效解决ABA问题。<code>AtomicStampedReference</code>类</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="15-volatile关键字"><a href="#15-volatile关键字" class="headerlink" title="15. volatile关键字"></a>15. volatile关键字</h2><h3 id="15-1-volatile简介"><a href="#15-1-volatile简介" class="headerlink" title="15.1 volatile简介"></a>15.1 <code>volatile</code>简介</h3><blockquote>
<p><code>volatile</code>是Java提供的一种轻量级的同步机制，它在<strong>多处理器的开发中</strong>保证了共享变量的可见性。<code>volatile</code>变量修饰符如果使用恰当，回避<code>sychronized</code>更轻量，因为它不会引起线程上下文的切换和调度。<strong><code>volatile</code>的作用主要有两个：实现可见性，禁止指令重排序。</strong></p>
</blockquote>
<h3 id="15-2-并发编程的三个基本概念"><a href="#15-2-并发编程的三个基本概念" class="headerlink" title="15.2 并发编程的三个基本概念"></a>15.2 并发编程的三个基本概念</h3><ol>
<li><strong>原子性</strong>  <ul>
<li>定义：一个操作或多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li>
<li><strong>处理器</strong>如何实现原子操作（解决缓存不一致的问题）：<ol>
<li>总线锁：所谓总线锁就是使用处理器提供的一个<code>LOCK#</code>信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</li>
<li>缓存锁：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</li>
</ol>
</li>
<li><strong>Java</strong>如何实现原子操作：<ol>
<li>锁：<code>volatile</code>可以保证单次操作的原子性，也就是不保证原子性，而<code>synchronized</code>可以保证原子性；</li>
<li>循环CAS</li>
</ol>
</li>
</ul>
</li>
<li><strong>可见性</strong><ul>
<li>定义：当多个线程访问同一变量时，一个线程修改了这个变量的值，其他线程能立即看到这个修改的值。</li>
<li>Java通过提供<code>volatile</code>保证可见性：（汇编指令中多了<code>lock</code>指令，Lock前缀的指令在多核处理器引发下面两件事，从而保证可见性）  <ol>
<li>当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；</li>
<li>这个写操作会导致其他线程中的缓存无效。（通过缓存一致性协议来做到）</li>
</ol>
</li>
<li>总结：底层原理是汇编中的LOCK指令，该指令使得当前处理器缓存行中的数据写回到系统内存，这个写操作通过缓存一致性协议使得其他CPU里缓存的该共享变量的副本无效，要想使用该共享变量，必须重新从主存中读取。从而保证了共享变量的可见性。</li>
</ul>
</li>
<li><strong>有序性</strong><ul>
<li>定义：程序的执行顺序按照代码的先后顺序执行。</li>
<li>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</li>
<li><code>volatile</code>可以保证一定的有序性：  <ol>
<li>当程序执行到<code>volatile</code>变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</li>
<li>在进行指令优化时，不能将在对<code>volatile</code>变量访问的语句放在其后面执行，也不能把<code>volatile</code>变量后面的语句放到其前面执行。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="15-3-volatile原理总结："><a href="#15-3-volatile原理总结：" class="headerlink" title="15.3 volatile原理总结："></a>15.3 <code>volatile</code>原理总结：</h3><p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”<br>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：  </p>
<ol>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li>
</ol>
<h3 id="15-4-synchronized关键字和-volatile-关键字的区别"><a href="#15-4-synchronized关键字和-volatile-关键字的区别" class="headerlink" title="15.4 synchronized关键字和 volatile 关键字的区别"></a>15.4 <code>synchronized</code>关键字和 <code>volatile</code> 关键字的区别</h3><ol>
<li><code>volatile</code>本质上是在告诉JVM缓存中的变量值是不确定的，需要从共享内存中读取；而<code>synchronized</code>是只允许一个线程访问该变量，其他线程被阻塞，直到该线程操作完为止；</li>
<li><code>volatile</code>是在变量级别，而<code>synchronized</code>是在变量、方法和类级别；</li>
<li><code>volatile</code>仅能保证变量的修改可见性，不能保证原子性；而<code>synchronized</code>能保证修改可见性和原子性；</li>
<li><code>volatile</code>不会造成线程阻塞，<code>synchronized</code>可能会造成线程阻塞；</li>
<li><code>volatile</code>不会被编译器优化，<code>synchronized</code>可以被编译器优化；</li>
<li><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而<code>synchronized</code>关键字解决的是多个线程之间访问资源的同步性</strong>；</li>
</ol>
<h2 id="16-synchronized关键字"><a href="#16-synchronized关键字" class="headerlink" title="16. synchronized关键字"></a>16. synchronized关键字</h2><h3 id="16-1-对于synchronized关键字的了解"><a href="#16-1-对于synchronized关键字的了解" class="headerlink" title="16.1. 对于synchronized关键字的了解"></a>16.1. 对于synchronized关键字的了解</h3><p><strong><code>synchronized</code>解决的是多个线程访问资源的同步性，<code>synchronized</code>可以保证被它修饰的方法或代码块在任意时刻只有一个线程执行</strong>；另外在早期的java版本中<code>synchronized</code>属于重量级锁，效率低下。<br>为什么呢？<br>这是因为监视器锁(monitor)是依赖于底层的操作系统的<code>Mutex Lock</code>实现的，Java线程是映射到操作系统的原生线程上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程的切换需要从用户态转换成核心态，这个转换需要相对较长的时间，时间成本比较高。<br>但Java6之后java官方从JVM层面对<code>synchronized</code>较大优化。JDK1.6之后对锁的实现引入大量优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。  </p>
<h3 id="16-2-synchronized关键字的使用"><a href="#16-2-synchronized关键字的使用" class="headerlink" title="16.2. synchronized关键字的使用"></a>16.2. synchronized关键字的使用</h3><ul>
<li>三种方式：   <ol>
<li><strong>修饰实例方法</strong>：作用于当前对象实例加锁，进入同步代码前要获得<strong>当前对象实例的锁</strong></li>
<li><strong>修饰静态方法</strong>：也就是给当前类加锁，会作用类的所有对象实例。要获得当前class的锁</li>
<li><strong>修饰代码块</strong>：指定加锁对象，对给定对象&#x2F;类加锁。<code>synchronized(this|object)</code> 表示进入同步代码库前<strong>要获得给定对象的锁</strong>。<code>synchronized(类.class)</code> 表示进入同步代码前要获得<strong>当前 class 的锁</strong></li>
</ol>
</li>
<li>总结：修饰静态方法和代码块都是给class上锁修饰实例方法是给对象实例上锁；</li>
<li><strong>双重校检锁实现对象单例模式</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="literal">null</span>)</span><br><span class="line">					instance = <span class="keyword">new</span> <span class="title class_">instance</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>instance = new instance()</code>实际上分为三步：  <ol>
<li>为instance分配内存空间</li>
<li>初始化instance</li>
<li>设置instance指向刚分配的内存地址<br>  <strong>所以要用volatile修饰instance，从而禁止jvm的指令重排，防止多线程访问时，由于2 3 重排导致线程访问到一个还没有被初始化的对象；</strong></li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="16-3-synchronized关键字的底层原理"><a href="#16-3-synchronized关键字的底层原理" class="headerlink" title="16.3. synchronized关键字的底层原理"></a>16.3. synchronized关键字的底层原理</h3><p><strong>synchronized关键字底层原理是属于JVM层面的</strong></p>
<ol>
<li><strong>synchronized修饰同步块时</strong>：从java字节码可以看出，synchronized同步语句块是使用<code>monitorenter</code>和<code>monitorexit</code>来实现的，<code>monitorenter</code>指向进入同步代码块的开始位置，<code>monitorexit</code>指向同步代码块的结束位置。当执行<code>monitorenter</code>时，线程试图获取锁也就是<strong>获取对象监视器monitor</strong>的所有权。<ul>
<li>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为0则表示锁可以被获取，获取后将锁的计数器设为1也就是加1；</li>
<li>在执行<code>monitorexit</code>时，将锁计数器设为0，表明锁被释放。</li>
<li>如果获取对象锁失败，当前线程就要被阻塞等待，直到锁被另一个线程释放为止。</li>
</ul>
</li>
<li><strong>synchronized修饰方法时</strong>：修饰方法时没有使用<code>monitorenter</code>和<code>monitorexit</code>指令，而是使用<code>ACC_SYNCHRONIZED</code>标识，该标识指明了该方法是一个同步方法。JVM通过该<code>ACC_SYNCHRONIZED</code>标识来辨别一个方法是否被声明为一个同步方法，从而执行相应的同步调用。</li>
<li>总结：synchronized修饰同步语句块的实现时，使用<code>monitorenter</code>和<code>monitorexit</code>指令，其中<code>monitorenter</code>指令指向同步语句块的开头位置，<code>monitorexit</code>指令指向同步语句块的结束位置；修饰方法时，使用<code>ACC_SYNCHRONIZED</code>标识，该标识指明了该方法是一个同步方法。</li>
</ol>
<h3 id="16-4-synchronized锁状态转换（锁优化）"><a href="#16-4-synchronized锁状态转换（锁优化）" class="headerlink" title="16.4. synchronized锁状态转换（锁优化）"></a>16.4. synchronized锁状态转换（锁优化）</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xdyixia/p/9364247.html">csdn锁优化</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuqinglong/p/9945618.html">Java6及以上版本对synchronized的优化</a><br>JDK1.6之后，对锁的实现引入了大量的优化，如<strong>自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁</strong>等技术来减少锁操作的开销；<br><strong>锁主要存在4种状态：无锁、偏向锁、轻量级锁、重量级锁状态</strong>，他们会随着竞争的激烈而逐渐升级，但不会降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<ol>
<li><p>自旋锁：<br> 线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对于CPU来说是一件很沉重的工作，会给系统的并发性能带来很大压力。但在很多应用上，对象锁的持续状态通常很短，为了这么短的持续时间而频繁的进行阻塞和唤醒线程很不值得，因此<strong>引入了自旋锁</strong>。  </p>
<p> <strong>所谓自旋锁，就是让试图获取锁（该锁已被其他线程获取）的线程等待一段时间，不会被立即阻塞，看持有锁的线程会不会很快释放锁。</strong>   </p>
<p> 怎么等待？<strong>就是执行一段无意义的循环即可（自旋）</strong>   </p>
<p> 但自旋不能替代阻塞，虽然它避免了线程切换的开销，但是也占用了处理器的时间。如果持有锁的线程很快就释放了锁，那自旋的效率就非常好。但如果不是这样，自旋就会白白浪费处理器资源，反而带来性能上的下降。  </p>
<p> 所以自旋的时间（也就是次数）应该有一定的限度，当超过了这个限度之后还是没有获取锁，那么该线程就应当被挂起（也就是阻塞）。  </p>
</li>
<li><p>适应性自旋锁：<br> JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。  </p>
<p> 线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。  </p>
</li>
<li><p>偏向锁：<br> 大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要用CAS操作来加锁和解锁，只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得锁；如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（标识当前是偏向锁）：如果没有设置，使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。   </p>
<p> <strong>偏向锁的撤销：</strong>  </p>
<p> **偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。**偏向锁的撤销，需要等到全局安全点（此时没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。  </p>
</li>
<li><p>轻量级锁：<br> 轻量级锁是由偏向锁升级而来的，一个线程获取偏向锁进入同步块的情况下，若第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；  </p>
<ol>
<li><strong>轻量级锁加锁</strong>：线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，然后将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换成指向锁记录的指针。如果成功，当前线程获得锁；如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。  </li>
<li><strong>轻量级锁解锁</strong>：轻量级锁解锁时，会使用原子得CAS操作将栈帧中的Displaced Mark Word替换到对象头中，如果成功，则说明没有竞争发生，解锁成功；如果失败，则说明当前锁存在竞争，轻量级锁就会膨胀为重量级锁。</li>
</ol>
</li>
<li><p>重量级锁：<br> **因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁得线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。**当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。  </p>
<ol>
<li>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</li>
</ol>
</li>
</ol>
<h3 id="16-5-synchronized和ReentrantLock的区别和联系："><a href="#16-5-synchronized和ReentrantLock的区别和联系：" class="headerlink" title="16.5. synchronized和ReentrantLock的区别和联系："></a>16.5. synchronized和ReentrantLock的区别和联系：</h3><ol>
<li>两者都是可重入锁<blockquote>
<p>可重入锁表示该锁能够支持一个线程对资源的重复加锁。</p>
</blockquote>
</li>
<li>两者都是加锁方式同步，而且都是阻塞式同步。</li>
<li><code>syn</code>操作Mark Word，而<code>lock</code>调用<code>Unsafe</code>的<code>park()</code>方法；</li>
<li><code>synchronized</code>是基于JVM的，而<code>ReentrantLock</code>是基于API的；</li>
<li><code>ReentrantLock</code>比<code>synchronized</code>增加了一些高级功能：<ol>
<li><strong>等待可中断</strong>：<code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。  </li>
<li><strong>可实现公平锁</strong>:<code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li><strong>锁可以绑定多个条件</strong>：<code>ReentrantLock</code>可以同时绑定多个<code>Condition</code>对象，只需多次调用<code>newCondition</code>方法即可。<code>synchronized</code>中，锁对象的<code>wait()</code>和<code>notify()</code>或<code>notifyAll()</code>方法可以实现一个隐含的条件。但如果要和多于一个的条件关联的时候，就不得不额外添加一个锁。</li>
</ol>
</li>
</ol>
<h2 id="17-AQS，基于AQS实现的lock-CountDownLatch、CyclicBarrier、Semaphore介绍"><a href="#17-AQS，基于AQS实现的lock-CountDownLatch、CyclicBarrier、Semaphore介绍" class="headerlink" title="17. AQS，基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore介绍"></a>17. AQS，基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore介绍</h2><h3 id="17-1-AQS简介"><a href="#17-1-AQS简介" class="headerlink" title="17.1 AQS简介"></a>17.1 AQS简介</h3><blockquote>
<p>AQS是一个用来构建锁和或者其他同步器组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队操作。<br>同步器的主要使用方式是继承，<strong>子类通过继承并实现它的抽象方法来管理同步状态</strong>，这时就需要使用同步器提供的三个方法：<code>getState()</code>、<code>setState(int newState)</code>、<code>compareAndSetState(int expect, int update)</code>来进行操作，它们能够保证状态的改变是安全的。<strong>子类推荐被定义为自定义同步组件的静态内部类</strong>，也就是<strong>自定义同步组件implements Lock，然后自定义同步组件里有一个静态内部类，这个静态类extends AQS，并实现获取和释放同步状态的抽象方法。</strong><br>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。  </p>
</blockquote>
<h3 id="17-2-AQS的使用"><a href="#17-2-AQS的使用" class="headerlink" title="17.2 AQS的使用"></a>17.2 AQS的使用</h3><ol>
<li>AQS支持两种同步方式<ul>
<li>独占式</li>
<li>共享式</li>
</ul>
</li>
<li>同步器的设计是基于模板方法模式的，一般的使用方式为：<ol>
<li>使用者继承同步器并重写其指定的方法（重写对共享资源state获取和释放的方法）</li>
<li>将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</li>
</ol>
</li>
<li>重写同步器指定的方法时，需要使用同步器提供的3个方法来访问或修改同步状态：<ol>
<li><code>getState()</code>：获取当前同步状态</li>
<li><code>setState(int newState)</code>：设置当前同步状态</li>
<li><code>compareAndSetState(int expect, int update)</code>：使用CAS设置当前状态，该方法能够保证状态设置的原子性</li>
</ol>
</li>
<li>同步器可重写的方法：<ol>
<li><code>protected boolean tryAcquire(int arg)</code> : 独占式获取同步状态，试着获取，成功返回true，反之为false    </li>
<li><code>protected boolean tryRelease(int arg)</code> ：独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态；</li>
<li><code>protected int tryAcquireShared(int arg)</code> ：共享式获取同步状态，返回值大于等于0，代表获取成功；反之获取失败；</li>
<li><code>protected boolean tryReleaseShared(int arg)</code> ：共享式释放同步状态，成功为true，失败为false</li>
<li><code>protected boolean isHeldExclusively()</code> ： 是否在独占模式下被线程占用。</li>
</ol>
</li>
</ol>
<h3 id="17-3-AQS实现分析"><a href="#17-3-AQS实现分析" class="headerlink" title="17.3 AQS实现分析"></a>17.3 AQS实现分析</h3><ol>
<li><strong>同步队列</strong>：同步器依赖内部的同步队列（一个FIFO的双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点并将其加入同步队列，并阻塞该线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。节点是构成同步队列的基础，同步器有头节点和尾节点的引用。同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。线程若获取同步状态失败，则被构造成节点加入同步队列尾部，这个加入过程通过<code>compareAndSetTail(Node expect, Node update)</code>保证线程安全。</li>
<li><strong>独占式同步状态获取和释放</strong>：在获取同步状态时，同步器维护一个队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋，如果还获取不到就阻塞该线程，而被阻塞线程的唤醒主要靠前驱节点的出队或阻塞线程被中断来实现。移出队列的条件是前驱节点为头节点且该线程获取同步状态成功。在释放同步状态时，同步器调用<code>tryRelease(int arg)</code>方法释放同步状态，然后唤醒头结点的后继节点。</li>
<li><strong>共享式同步状态获取和释放</strong>：与独占式的主要区别在于同一时刻能否有多个线程同时获取到同步状态；<code>tryAcquireShared(int arg)</code>如果返回的值大于0，说明获取同步状态成功。</li>
</ol>
<h3 id="17-4-Java中的并发工具类"><a href="#17-4-Java中的并发工具类" class="headerlink" title="17.4 Java中的并发工具类"></a>17.4 Java中的并发工具类</h3><ol>
<li><code>Semaphore</code>(信号量)-允许多个线程同时访问： <code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</li>
<li><code>CountDownLatch</code> （倒计时器）： <code>CountDownLatch</code> 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li><code>CyclicBarrier</code>(循环栅栏)： <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> <code>类似。CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>
</ol>
<h2 id="17-5-CyclicBarrier-和-CountDownLatch-的区别"><a href="#17-5-CyclicBarrier-和-CountDownLatch-的区别" class="headerlink" title="17.5 CyclicBarrier 和 CountDownLatch 的区别"></a>17.5 CyclicBarrier 和 CountDownLatch 的区别</h2><ol>
<li><code>CountDownLatch</code>的计数器只能使用一次，而<code>CyclicBarrier</code>的计数器可以使用<code>reset()</code>方法重置，所以<code>CyclicBarrier</code>能处理更复杂的业务场景。</li>
<li><code>CyclicBarrier</code>还提供了其他有用的方法，比如<code>getNumberWaiting</code>方法可以获得<code>CyclicBarrier</code>阻塞的线程数量，<code>isBroken()</code>方法用来了解阻塞的线程是否被中断。</li>
</ol>
<h2 id="18-非公平锁和公平锁"><a href="#18-非公平锁和公平锁" class="headerlink" title="18. 非公平锁和公平锁"></a>18. 非公平锁和公平锁</h2><ol>
<li><strong>非公平锁</strong>：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。<ul>
<li>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</li>
<li>缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</li>
</ul>
</li>
<li><strong>公平锁</strong>：多个线程按照申请锁的顺序去获得锁，线程会直接到队列中去排队，永远都是队列的第一位才能得到锁<ul>
<li>优点：所有线程都能得到资源，不会饿死</li>
<li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</li>
</ul>
</li>
</ol>
<h2 id="19-JUC原子类"><a href="#19-JUC原子类" class="headerlink" title="19. JUC原子类"></a>19. JUC原子类</h2><h3 id="19-1-介绍一下Atomic原子类"><a href="#19-1-介绍一下Atomic原子类" class="headerlink" title="19.1 介绍一下Atomic原子类"></a>19.1 介绍一下Atomic原子类</h3><blockquote>
<p>可认为是其操作都是不可分割的类</p>
</blockquote>
<h3 id="19-2-JUC包中的原子类是哪4类"><a href="#19-2-JUC包中的原子类是哪4类" class="headerlink" title="19.2 JUC包中的原子类是哪4类"></a>19.2 JUC包中的原子类是哪4类</h3><ol>
<li>原子更新基本类型类<ol>
<li><code>AtomicInteger</code>：原子更新整型</li>
<li><code>AtomicLong</code>：原子更新长整型</li>
<li><code>AtomicBoolean</code>：原子更新布尔类型</li>
</ol>
</li>
<li>原子更新数组类型类<ol>
<li><code>AtomicIntegerArray</code>：原子更新整型数组里的元素</li>
<li><code>AtomicLongArray</code>：原子更新长整型数组里的元素</li>
<li><code>AtomicReferenceArray</code>：原子更新引用类型数组里的元素</li>
</ol>
</li>
<li>引用类型<ol>
<li><code>AtomicReference</code>：原子更新引用类型</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段</li>
<li><code>AtomicMarkableReference</code>：原子更新带有标记位的引用类型</li>
</ol>
</li>
<li>字段类型（对象的属性修改）<ol>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新整型的字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整型的字段的更新器</li>
<li><code>AtomisStampedReference</code>：原子更新带有版本号的引用类型。<strong>该类将整数值与引用关联起来，可解决CAS进行原子更新时可能出现的ABA问题</strong></li>
</ol>
</li>
</ol>
<h3 id="19-3-AtomicInteger的使用"><a href="#19-3-AtomicInteger的使用" class="headerlink" title="19.3 AtomicInteger的使用"></a>19.3 AtomicInteger的使用</h3><ol>
<li>常用方法 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure></li>
<li>使用实例 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicIntegerTest</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">	<span class="comment">//使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">				count.incrementAndGet();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> count.get();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="19-4-AtomicInteger类的原理"><a href="#19-4-AtomicInteger类的原理" class="headerlink" title="19.4 AtomicInteger类的原理"></a>19.4 AtomicInteger类的原理</h3><blockquote>
<p>AtomicInteger 类主要利用unsafe类实现的CAS机制 + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
</blockquote>
<ol>
<li>读：AtomicInteger本身提供了get()来获取value值，该方法直接返回value变量。因为value变量是volatile类型，这就保证get()读到的是最新值，因为是直接从主内存中读取value 。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;           </span><br><span class="line"><span class="comment">// volatile保证get()读到的是最新值，因为直接从主内存中读取value </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;    <span class="keyword">return</span> value;    &#125;</span><br></pre></td></tr></table></figure></li>
<li>写：这个方法的做法为先获取到当前的 value 属性值，然后将 value 加 1，赋值给一个局部的 next 变量，然而，这两步都是非线程安全的，但是内部有一个死循环，不断去做compareAndSet操作，直到成功为止，也就是修改的根本在compareAndSet方法里面。compareAndSet()方法的代码如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">			<span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">				<span class="keyword">return</span> current;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="20-两个线程读，一个线程写，如何实现，不用锁可以吗"><a href="#20-两个线程读，一个线程写，如何实现，不用锁可以吗" class="headerlink" title="20. 两个线程读，一个线程写，如何实现，不用锁可以吗"></a>20. 两个线程读，一个线程写，如何实现，不用锁可以吗</h2><br>
<br>
<br>    
	  
<h2 id="21-线程池作用、参数、有几种"><a href="#21-线程池作用、参数、有几种" class="headerlink" title="21. 线程池作用、参数、有几种"></a>21. 线程池作用、参数、有几种</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jay-huaxiao/p/11454416.html">csdn线程池</a></p>
<h3 id="21-1-线程池的好处："><a href="#21-1-线程池的好处：" class="headerlink" title="21.1 线程池的好处："></a>21.1 线程池的好处：</h3><ol>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ol>
<h2 id="21-2-线程池的创建"><a href="#21-2-线程池的创建" class="headerlink" title="21.2 线程池的创建"></a>21.2 线程池的创建</h2><p>线程池可以通过<code>ThreadPoolExecutor</code>来创建线程，几个核心参数：  </p>
<ol>
<li><code>corePoolSize</code>：核心线程数最大值，核心线程就算空闲也不会被回收</li>
<li><code>maximumPoolSize</code>：最大线程数</li>
<li><code>keepAliveTime</code>：非核心线程空闲时间保留的最长时间</li>
<li><code>unit</code>：计算上述时间的时间单位</li>
<li><code>workQueue</code>：存放任务的阻塞队列（工作队列）<ol>
<li><code>ArrayBlockingQueue</code>：是一个基于数组结构的<strong>有界</strong>阻塞队列，按FIFO原则对元素排序；</li>
<li><code>LinkedBlockingQueue</code>：基于链表结构的<strong>无界</strong>阻塞队列，按FIFO原则对元素进行排序；吞吐量高于<code>ArrayBlockingQueue</code>;静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列；</li>
<li><code>SynchronousQueue</code>：不存储元素的阻塞队列，每个元素的插入必须要等到另一个元素调用移除操作，否则插入操作一直处于阻塞状态；吞吐量高于<code>LinkedBlockingQueue</code>；静态工厂方法<code>Executors.newCachedThreadPool</code>使用了这个队列。</li>
<li><code>PriorityBlockingQueue</code>：具有优先级的无限阻塞队列</li>
</ol>
</li>
<li><code>threadFactory</code>：创建线程的工厂</li>
<li><code>hanlder</code>：拒绝策略；当线程数目已到达最大线程数且工作队列已满，这时如果还有任务被提交到线程池，线程池需要采用一定的饱和策略，一共4种。 <ol>
<li><code>AbortPolicy</code>    ：        直接抛出异常（默认）</li>
<li><code>DiscardPolicy</code>    ：        直接不处理，丢弃任务</li>
<li><code>DiscardOldestPolicy</code>：    丢弃队列中最老的任务，并执行当前任务</li>
<li><code>CallerRunsPolicy</code>：        交给线程池调用所在的线程进行处理</li>
</ol>
</li>
</ol>
<h3 id="21-3-线程池的任务执行流程："><a href="#21-3-线程池的任务执行流程：" class="headerlink" title="21.3 线程池的任务执行流程："></a>21.3 线程池的任务执行流程：</h3><p>提交一个新任务到线程池中：  </p>
<ol>
<li>若线程池中存活的核心线程数少于<code>corePoolSize</code>，则创建新的核心线程去处理提交的任务。</li>
<li>如果运行的线程数等于或多于<code>corePoolSize</code>，则将任务加入工作队列中。</li>
<li>如果工作队列已满，则创建新的线程处理任务。（创建的是非核心线程，这种线程空闲一定时间后会被回收掉）</li>
<li>如果创建新线程将使当前运行的线程超出<code>maximumPoolSize</code>，任务被拒绝，拒绝策略有四种，由<code>handler</code>参数指定。<blockquote>
<p>总结：当一个新任务提交到线程池中时，优先让核心线程来处理任务，如果当前核心线程数已达到<code>corePoolSize</code>数目，而且都在运行中，就把当前任务加入工作队列中等待；如果工作队列也满了，就创建非核心线程来处理该任务，非核心线程空闲一段时间就会被回收。如果线程池内的线程数已达到最大线程数，不能创建新线程，就只能采用拒绝策略拒绝该任务。</p>
</blockquote>
</li>
</ol>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">核心线程比作公司正式员工</span><br><span class="line">非核心线程比作外包员工</span><br><span class="line">阻塞队列比作需求池</span><br><span class="line">提交任务比作提需求</span><br><span class="line"></span><br><span class="line">当产品提个需求，正式员工（核心线程）先接需求（执行任务）</span><br><span class="line">如果正式员工都有需求在做，即核心线程数已满），产品就把需求先放需求池（阻塞队列）。</span><br><span class="line">如果需求池(阻塞队列)也满了，但是这时候产品继续提需求,怎么办呢？那就请外包（非核心线程）来做。</span><br><span class="line">如果所有员工（最大线程数也满了）都有需求在做了，那就执行拒绝策略。</span><br><span class="line">如果外包员工把需求做完了，它经过一段（keepAliveTime）空闲时间，就离开公司了。</span><br></pre></td></tr></table></figure>

<h2 id="22-Executor"><a href="#22-Executor" class="headerlink" title="22. Executor"></a>22. Executor</h2><h3 id="22-1-Executor框架简介"><a href="#22-1-Executor框架简介" class="headerlink" title="22.1 Executor框架简介"></a>22.1 Executor框架简介</h3><blockquote>
<p>从JDK5开始，把工作单元和执行机制分离开来。工作单元包括<code>Runnable</code>和<code>Callable</code>，而执行机制由<code>Executor</code>框架提供。<br>在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。</p>
</blockquote>
<ul>
<li>Executor框架的结构，主要由三部分：<ol>
<li>任务。实现<code>Runnable</code>或<code>Callable</code>接口的对象。</li>
<li>任务的执行。包括任务执行机制的核心接口<code>Executor</code>，以及继承自<code>Executor</code>的<code>ExecutorService</code>接口。Executor框架有两个关键类实现了<code>ExecutorService</code>接口：<code>ThreadPoolExecutor</code>和<code>ScheduledThreadPoolExecutor</code>。</li>
<li>异步计算的结果。包括接口<code>Future</code>和实现<code>Future</code>接口的<code>FutureTask</code>类。</li>
</ol>
</li>
<li>Executor框架的使用流程：  <ol>
<li>主线程首先要创建<code>Runnable</code>或<code>Callable</code>接口的任务对象。（工具类Executors可以把一个<code>Runnable</code>对象封装为一个<code>Callable</code>对象）</li>
<li>可以把实现<code>Runnable</code>或<code>Callable</code>对象交给<code>ExecutorService</code>执行。（<code>execute()</code>或<code>submit()</code>方法，execute没返回值，submit有返回值）</li>
<li>如果执行的是<code>ExecutorService.submit()</code>，<code>ExecutorService</code>将返回一个实现<code>Future</code>接口的对象（<code>FutureTask</code>对象）。由于<code>FutureTask</code>实现了<code>Runnable</code>，程序员也可以创建<code>FutureTask</code>，然后直接交给<code>ExecutorService</code>执行。</li>
<li>最后，主线程可以执行<code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行<code>FutureTask,cancel(boolean mayInterruptIfRunning)</code>来取消此任务的执行。</li>
</ol>
</li>
<li><code>Executor</code>框架的成员<ol>
<li><code>ThreadPoolExecutor</code><ol>
<li><code>FixedThreadPool</code></li>
<li><code>SingleThreadExecutor</code></li>
<li><code>CachedThreadPool</code></li>
</ol>
</li>
<li><code>ScheduledThreadPoolExecutor</code><ol>
<li><code>ScheduledThreadPoolExecutor</code></li>
<li><code>SingleThreadScheduledExecutor</code></li>
</ol>
</li>
<li><code>Future</code>接口<ol>
<li>实现该接口的<code>FutureTask</code>类</li>
</ol>
</li>
<li><code>Runnable</code>接口</li>
<li><code>Callable</code>接口</li>
<li><code>Executors</code></li>
</ol>
</li>
</ul>
<h3 id="22-2-生命周期"><a href="#22-2-生命周期" class="headerlink" title="22.2 生命周期"></a>22.2 生命周期</h3><blockquote>
<p>ExecutorService 接口继承自 Executor 接口，定义了终止、提交、执行任务、跟踪任务返回结果等方法。  </p>
</blockquote>
<ul>
<li>ExecutorService 的生命周期有三种状态：运行、关闭和已终止。<ol>
<li>execute（Runnable command）：履行 Ruannable 类型的任务,</li>
<li>submit（task）：可用来提交 Callable 或 Runnable 任务，并返回代表此任务的 Future 对象</li>
<li>shutdown（）：在完成已提交的任务后封闭办事，不再接管新任务,</li>
<li>shutdownNow（）：停止所有正在履行的任务并封闭办事。</li>
<li>isTerminated（）：测试是否所有任务都履行完毕了。,</li>
<li>isShutdown（）：测试是否该 ExecutorService 已被关闭</li>
</ol>
</li>
</ul>
<h3 id="22-3-ThreadPoolExecutor详解"><a href="#22-3-ThreadPoolExecutor详解" class="headerlink" title="22.3 ThreadPoolExecutor详解"></a>22.3 ThreadPoolExecutor详解</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">是Executor最核心的类，是线程池的实现类，主要由4个组件构成：</span><br><span class="line">	1. corePool：核心线程池大小</span><br><span class="line">	2. maximumPool：最大线程池大小</span><br><span class="line">	3. BlockingQueue：工作队列</span><br><span class="line">	4. hanlder：拒绝策略</span><br><span class="line"></span><br><span class="line">可以创建3种类型的ThreadPoolExecutor:</span><br><span class="line">	1. FixedThreadPool</span><br><span class="line">	2. SingleThreadExecutor</span><br><span class="line">	3. CachedThreadPool</span><br><span class="line"></span><br><span class="line">面试题：使用无界队列的线程池会导致内存飙升吗？</span><br><span class="line">答案 ：会的，FixedThreadPool和SingleThreadExecutor使用了无界的阻塞队列LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长(比如，上面demo设置了10秒)，会导致队列的任务越积越多，导致机器内存使用不停飙升， 最终导致OOM。</span><br></pre></td></tr></table></figure>
<ol>
<li><code>FixedThreadPool</code><ul>
<li>适用于为了满足资源管理的需求，需要限制当前线程数量的应用场景，比如负载比较重的服务器。</li>
<li>特点：<ol>
<li>核心线程数和最大线程数大小一样</li>
<li>没有所谓的非空闲时间，即keepAliveTime为0</li>
<li>阻塞队列为无界队列LinkedBlockingQueue</li>
</ol>
</li>
<li>工作机制：<ol>
<li>提交任务</li>
<li>如果线程数少于核心线程，创建核心线程执行任务</li>
<li>如果线程数等于核心线程（线程池已经完成预热），把任务添加到LinkedBlockingQueue阻塞队列</li>
<li>如果线程执行完任务，去阻塞队列取任务，继续执行。</li>
</ol>
</li>
</ul>
</li>
<li><code>SingleThreadExecutor</code><ul>
<li>适用于需要保证顺序的执行各个任务；并且在任意时间点，不会有多个线程活动的场景</li>
<li>特点：<ol>
<li>核心线程数为1</li>
<li>最大线程数也为1</li>
<li>阻塞队列是LinkedBlockingQueue</li>
<li>keepAliveTime为0</li>
</ol>
</li>
<li>工作机制：<ol>
<li>提交任务</li>
<li>线程池是否有一条线程在，如果没有，新建线程执行任务</li>
<li>如果有，将任务加到阻塞队列</li>
<li>当前的唯一线程，从队列取任务，执行完一个，再继续取，一个人（一条线程）夜以继日地干活。</li>
</ol>
</li>
</ul>
</li>
<li><code>CachedThreadPool</code><ul>
<li>是大小无界的线程池，是用于执行很多短期异步任务的小程序，或者是负载较轻的服务器。</li>
<li>特点：<ol>
<li>核心线程数为0</li>
<li>最大线程数为Integer.MAX_VALUE</li>
<li>阻塞队列是SynchronousQueue</li>
<li>非核心线程空闲存活时间为60秒<blockquote>
<p>当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。</p>
</blockquote>
</li>
</ol>
</li>
<li>工作机制：<ol>
<li>提交任务</li>
<li>因为没有核心线程，所以任务直接加到SynchronousQueue队列。</li>
<li>判断是否有空闲线程，如果有，就去取出任务执行。</li>
<li>如果没有空闲线程，就新建一个线程执行。</li>
<li>执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="22-4-线程池状态转换"><a href="#22-4-线程池状态转换" class="headerlink" title="22.4 线程池状态转换"></a>22.4 线程池状态转换</h3><p><img src="/./image/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.jpg" alt="线程池状态转换"></p>
<h2 id="23-Java中如何正常终止线程？"><a href="#23-Java中如何正常终止线程？" class="headerlink" title="23. Java中如何正常终止线程？"></a>23. Java中如何正常终止线程？</h2><ol>
<li>使用退出标志，使线程正常退出，也就是当 run() 方法完成后线程中止。</li>
<li>使用 interrupt 方法中断线程。<blockquote>
<p>stop()，suspend() 和 resume()已被弃用</p>
</blockquote>
</li>
</ol>
<h2 id="26-主线程可以捕获子线程抛出的异常吗？"><a href="#26-主线程可以捕获子线程抛出的异常吗？" class="headerlink" title="26. 主线程可以捕获子线程抛出的异常吗？"></a>26. 主线程可以捕获子线程抛出的异常吗？</h2><p>正常情况下，如果不做任何处理，捕获不到。<br>要想捕获，要用ExecutorService。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/08/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E9%97%AE%E9%A2%98-%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E5%BD%92%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fremont">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="有间栈">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 有间栈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/08/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E9%97%AE%E9%A2%98-%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E5%BD%92%E6%A1%A3/" class="post-title-link" itemprop="url">股票买卖问题-历史学习记录归档</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-08 17:34:24 / 修改时间：17:37:37" itemprop="dateCreated datePublished" datetime="2025-06-08T17:34:24+08:00">2025-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>760</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="股票买卖问题总结"><a href="#股票买卖问题总结" class="headerlink" title="股票买卖问题总结"></a>股票买卖问题总结</h1><h2 id="题号"><a href="#题号" class="headerlink" title="题号"></a>题号</h2><p>121<br>122<br>123<br>188<br>309<br>714  </p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ol>
<li>状态有三个：i表示是第几天，k表示当前可用的交易次数，0 or 1 分别表示现在手中没有持有或者持有股票</li>
<li>定义dp数组：   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line"><span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len][k][<span class="number">2</span>];</span><br></pre></td></tr></table></figure></li>
<li>base case: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dp[-<span class="number">1</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment">//解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。</span></span><br><span class="line">dp[-<span class="number">1</span>][k][<span class="number">1</span>] = -infinity</span><br><span class="line"><span class="comment">//解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。</span></span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment">//解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。</span></span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line"><span class="comment">//解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。</span></span><br></pre></td></tr></table></figure></li>
<li>状态转移方程：   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i ++)&#123;</span><br><span class="line">    <span class="comment">//解释：今天我没有持有股票，有两种可能：</span></span><br><span class="line">    <span class="comment">//要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；</span></span><br><span class="line">    <span class="comment">//要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</span></span><br><span class="line">    dp[i][k][<span class="number">0</span>] = Math.max(</span><br><span class="line">        <span class="comment">// 昨天就没有股票</span></span><br><span class="line">        dp[i - <span class="number">1</span>][k][<span class="number">0</span>],</span><br><span class="line">        <span class="comment">//  昨天有股票，今天卖了</span></span><br><span class="line">        dp[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i]</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解释：今天我持有着股票，有两种可能：</span></span><br><span class="line">    <span class="comment">//要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；</span></span><br><span class="line">    <span class="comment">//要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。</span></span><br><span class="line">    dp[i][k][<span class="number">1</span>] = Math.max(</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        dp[i - <span class="number">1</span>][k][<span class="number">1</span>],</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        dp[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="k-1"><a href="#k-1" class="headerlink" title="k &#x3D; 1"></a>k &#x3D; 1</h2><blockquote>
<p>k &#x3D; 1 和 k &#x3D; inf 不同的地方在于k &#x3D; 1时 状态转移方程中的k和k-1是不一样的，而k&#x3D;inf时，k 和 k - 1可以认为一样；</p>
</blockquote>
<ol>
<li>化简模板中的状态转移方程  </li>
<li>用化简后的状态转移方程和模板中的base case 推出 初始条件：    <pre><code class="language-java">dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i])
因为k为定值1
dp[0][0] = 0;
dp[0][1] = - prices[0];
</code></pre>
</li>
</ol>
<h2 id="k-inf"><a href="#k-inf" class="headerlink" title="k &#x3D; inf"></a>k &#x3D; inf</h2><ol>
<li>化简模板中的状态转移方程<pre><code class="language-java">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])

我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
</code></pre>
</li>
<li>根据化简后的状态转移方程和base case推初始条件：<br> dp[0][0] &#x3D; 0;<br> dp[0][1] &#x3D; - prices[0];</li>
</ol>
<blockquote>
<p>总结就是先根据题意，化简模板中的状态转移方程，然后根据化简后的状态转移方程，推base case；就这么简单</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/08/MySQL%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fremont">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="有间栈">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 有间栈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/08/MySQL%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">Mysql常见问题-历史学习记录归档</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-08 17:31:20 / 修改时间：22:41:22" itemprop="dateCreated datePublished" datetime="2025-06-08T17:31:20+08:00">2025-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>27 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h2><p>事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能成功的对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。</p>
<h3 id="1-1-事务的四大特性-ACID"><a href="#1-1-事务的四大特性-ACID" class="headerlink" title="1.1 事务的四大特性 ACID"></a>1.1 事务的四大特性 ACID</h3><ol>
<li>原子性（Atomicity）<br>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，<strong>对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性</strong>。  </li>
<li>一致性（Consistency）<br>数据库总是从一个一致性的状态转换到另一个一致性的状态。<strong>只要事务没有提交，事务中所做的更改就不会保存到数据库中</strong>。</li>
<li>隔离性（Isolation）<br>通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。由<strong>隔离级别</strong>确定可不可见。</li>
<li>持久性（Durability）<br>一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</li>
</ol>
<h3 id="1-2-隔离级别"><a href="#1-2-隔离级别" class="headerlink" title="1.2 隔离级别"></a>1.2 隔离级别</h3><blockquote>
<p>在SQL标准中定义了四种隔离级别，每一种隔离级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。</p>
</blockquote>
<ol>
<li>READ UNCOMMITTED(未提交读)<br>事务中的修改，即使没有提交，对其他事务也都是可见的。<strong>事务可以读取未提交的数据，这也被称为脏读</strong>。</li>
<li>READ COMMITTED(提交读， 不可重复读)<br>大多数数据库的默认隔离级别都是READ COMMITTED（但Mysql不是），该级别满足前面提到的隔离性的简单定义：<strong>一个事务开始时，只能看见已经提交了的事务所作的修改。也就是说，一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫不可重复读，因为执行两次同样的查询，可能得到不一样的结果。</strong></li>
<li>REPEATABLE READ(可重复读)<br>MYSQL的默认隔离级别，REPEATABLE READ解决了脏读和不可重复读的问题。该级别可以保证同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读解决不了幻读问题。<strong>所谓幻读，是指当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行</strong>。InnoDB和XtraDB存储殷勤通过多版本并发控制解决了幻读问题。</li>
<li>SERIALIZABLE(可串行化)<br>最高隔离级别。强制事务串行执行，避免了幻读问题。简单来说，SERIALIZABLE会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用问题。</li>
</ol>
<h3 id="1-3-死锁"><a href="#1-3-死锁" class="headerlink" title="1.3 死锁"></a>1.3 死锁</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。</p>
<ul>
<li>InnoDB目前处理死锁的方法是：将持有最少行级排他锁的事务进行回滚（相对简单的死锁处理算法）。</li>
<li>死锁的产生有双重原因，有些是因为真正的数据冲突，这种情况通常很难避免，但有些则完全是由于存储引擎的实现方式导致的。<strong>死锁发生后，只需要部分或完全回滚其中一个事务，才能打破死锁</strong>。</li>
</ul>
<h3 id="1-4-MYSQL中的事务"><a href="#1-4-MYSQL中的事务" class="headerlink" title="1.4 MYSQL中的事务"></a>1.4 MYSQL中的事务</h3><ol>
<li>MYSQL中默认采用自动提交(AUTOCOMMIT)模式。也就是说，如果不是显示的开始一个事务，每个查询都被当做一个事务执行提交操作。</li>
<li><code>SET TRANSACTION ISOLATION</code>命令来设置隔离级别；</li>
<li><strong>隐式和显式锁定</strong>：InnoDB采用的是两阶段锁定协议。在事物的执行过程中，随时都可以执行锁定，锁只有执行COMMIT和ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。InnoDB也支持显示锁定，也支持LOCK TABLES和UNLOCK TABLES语句，这是在服务器层实现的，和存储引擎无关。</li>
</ol>
<h2 id="2-多版本并发控制-MVCC"><a href="#2-多版本并发控制-MVCC" class="headerlink" title="2. 多版本并发控制 MVCC"></a>2. 多版本并发控制 MVCC</h2><ol>
<li><strong>为了提升并发性能</strong>，MYSQL中的大多存储殷勤实现的都不是简单的行级锁，一般都同时实现了MVCC</li>
<li>可认为MVCC是行级锁的变种，很多情况避免了加锁操作，因此开销更低。实现了非阻塞的读操作，写操作也只锁定必要的行。</li>
<li><strong>MVCC的实现，是通过保存数据在某个时间点的快照来实现的</strong>。</li>
<li>MVCC的实现不同，分为<strong>乐观并发控制</strong>和<strong>悲观并发控制</strong></li>
<li>MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作；其他级别与MVCC不兼容，因为READ UNCOMMITED总是读取最新的数据行，而不是符合当前事务版本的数据行。</li>
<li>InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。存储的不是实际时间值，而是系统版本号。每开始一个新事物，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</li>
</ol>
<h2 id="3-存储引擎"><a href="#3-存储引擎" class="headerlink" title="3. 存储引擎"></a>3. 存储引擎</h2><ol>
<li><p>InnoDB  </p>
<ol>
<li>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。  </li>
<li>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。  </li>
<li>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</li>
<li>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</li>
<li>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</li>
</ol>
</li>
<li><p>MyISAM</p>
<ol>
<li>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</li>
<li>提供了大量的特性，包括压缩表、空间数据索引等。</li>
<li>不支持事务。</li>
<li>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</li>
<li>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</li>
<li>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</li>
</ol>
</li>
<li><p>InnoDB和MyISAM比较</p>
<ol>
<li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。MyISAM 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li>
<li>锁：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li>
<li>外键：InnoDB 支持外键。</li>
<li>备份：InnoDB 支持在线热备份。</li>
<li>是否支持MVCC ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。</li>
<li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>其它特性：MyISAM 支持压缩表和空间数据索引。</li>
</ol>
</li>
</ol>
<h2 id="4-数据库范式"><a href="#4-数据库范式" class="headerlink" title="4. 数据库范式"></a>4. 数据库范式</h2><ol>
<li>第一范式：<strong>要求字段达到原子性，使字段不可再分</strong>。每一列都是不可分割的基本数据项，即表的列的具有原子性,不可再分解，即列的信息，不能分解。<strong>不满足第一范式的数据库就不是关系型数据库</strong>。</li>
<li>第二范式：<strong>保证一张表只描述一件事情</strong>。也就是在满足第一范式的基础上，<strong>数据库表中所有非主键字段都完全依赖于主键字段</strong>。</li>
<li>第三范式：<strong>保证每列都和主键直接相关</strong>，也就是说表中的字段和主键直接对应不依靠其他中间字段，<strong>说白了就是，决定某字段值的必须是主键</strong>。<blockquote>
<p>总结：<br><strong>第一范式</strong>：确保每列的原子性（强调的是列的原子性，即列不能再分为其他几列）；若不满足则不是关系型数据库。<br><strong>第二范式</strong>：在第一范式的基础上更进一层，目标是确保表中的每列都和主键相关。(一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的部分)<br><strong>第三范式</strong>：在第二范式的基础上更进一层,目标是确保每列都和主键列直接相关,而不是间接相关(另外非主键列必须直接依赖于主键，不能存在传递依赖).</p>
</blockquote>
</li>
</ol>
<h2 id="5-乐观锁和悲观锁"><a href="#5-乐观锁和悲观锁" class="headerlink" title="5. 乐观锁和悲观锁"></a>5. 乐观锁和悲观锁</h2><blockquote>
<p>乐观锁和悲观锁是处理并发资源的常用手段，是一种思想，不能与mysql中提供的锁机制（表锁，行锁，排他锁，共享锁）混为一谈。</p>
</blockquote>
<h3 id="5-1-悲观锁"><a href="#5-1-悲观锁" class="headerlink" title="5.1 悲观锁"></a>5.1 悲观锁</h3><p>悲观锁指的是对数据被外界修改持悲观态度，因此在整个数据处理过程中将数据处于锁定状态。<strong>悲观锁的实现，大都依靠数据库提供的锁机制来实现</strong>。（可以理解为java中的synchronized关键字）。<strong>要使用悲观锁，首先要关闭mysql的自动提交：<code>set autocommit = 0</code>，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交；注意，mysql中的行级锁是基于索引的，如果sql没有走索引，那将使用表级锁把整张表锁住。</strong>。<br><strong>悲观锁的实现方式有两种：共享锁（读锁）和排他锁（写锁）</strong>   </p>
<ul>
<li><strong>共享锁（IS锁）</strong>：<code>SELECT ... LOCK IN SHARE MODE</code>，即在符合条件的rows上都加了共享锁，这样的话，其他session可以读取这些记录，也可以继续添加IS锁，但是无法修改这些记录直到你这个加锁的session执行完成(否则直接锁等待超时)。  </li>
<li><strong>排他锁（IX锁）</strong>: <code>SELECT ... FOR UPDATE</code> ，即在符合条件的rows上都加了排它锁，其他session也就无法在这些记录上添加任何的S锁或X锁。如果不存在一致性非锁定读的话，那么其他session是无法读取和修改这些记录的，但是innodb有非锁定读(快照读并不需要加锁)，for update之后并不会阻塞其他session的快照读取操作，除了select …lock in share mode和select … for update这种显示加锁的查询操作。</li>
</ul>
<p><strong>mysql InnoDB引擎默认的修改数据语句:update,delete,insert都会自动给涉及到的数据加上排他锁,select语句默认不会加任何锁类型</strong>。  </p>
<h3 id="5-2-乐观锁"><a href="#5-2-乐观锁" class="headerlink" title="5.2 乐观锁"></a>5.2 乐观锁</h3><p>乐观锁假设认为数据一般情况下不会产生冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突，则返回错误信息，让用户决定如何去做。（类似Java中的CAS操作）<br><strong>乐观锁的实现有两种方式：版本号和时间戳控制</strong>：    </p>
<ul>
<li>版本号控制的原理：<ol>
<li>为表中加一个 version 字段；</li>
<li>当读取数据时，连同这个 version 字段一起读出；</li>
<li>数据每更新一次就将此值加一；</li>
<li>当提交更新时，判断数据库表中对应记录的当前版本号是否与之前取出来的版本号一致，如果一致则可以直接更新，如果不一致则表示是过期数据需要重试或者做其它操作（PS：这完完全全就是 CAS 的实现逻辑呀~）</li>
</ol>
</li>
<li>时间戳控制：至于时间戳控制，其原理和版本号控制差不多，也是在表中添加一个 timestamp 的时间戳字段，然后提交更新时判断数据库中对应记录的当前时间戳是否与之前取出来的时间戳一致，一致就更新，不一致就重试。</li>
</ul>
<h2 id="6-内连接-左连接-右连接"><a href="#6-内连接-左连接-右连接" class="headerlink" title="6. 内连接 左连接 右连接"></a>6. 内连接 左连接 右连接</h2><ul>
<li>内连接：查询两张表的交集  </li>
<li>左连接：left join左边是主表，显示左边有的；右边如果没有就为null  </li>
<li>右连接：right join右边是主表，显示右边有的；左边如果没有就为null</li>
</ul>
<h2 id="7-B树和B-树"><a href="#7-B树和B-树" class="headerlink" title="7. B树和B+树"></a>7. B树和B+树</h2><blockquote>
<p>在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。  </p>
</blockquote>
<ol>
<li>B+树和B树的区别：  <ul>
<li>B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，<strong>B树在内部节点出现的索引项不会再出现在叶子节点中，而B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接</strong>。</li>
<li>B+树中所有叶子节点都是通过指针连接在一起，而B树不会。</li>
</ul>
</li>
<li>B+树的优点：  <ul>
<li>非叶子节点不会带上ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。</li>
<li>叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。</li>
</ul>
</li>
<li>B树的优点：<ul>
<li>对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。</li>
</ul>
</li>
</ol>
<h2 id="8-索引"><a href="#8-索引" class="headerlink" title="8. 索引"></a>8. 索引</h2><blockquote>
<p>索引（在MYSQL中也叫做键），是存储引擎用于快速找到记录的一种数据结构。索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
</blockquote>
<h3 id="8-1-索引的类型"><a href="#8-1-索引的类型" class="headerlink" title="8.1 索引的类型"></a>8.1 索引的类型</h3><ol>
<li><p>B-Tree索引  </p>
<blockquote>
<p>B-Tree索引能加快访问数据的速度，是因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么是找到对应的值，要么该记录不存在。</p>
</blockquote>
<ul>
<li><p>是大多数 MySQL 存储引擎的默认索引类型。</p>
</li>
<li><p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p>
</li>
<li><p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</p>
</li>
<li><p>可以指定多个列作为索引列，多个索引列共同组成键。</p>
</li>
<li><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>
</li>
<li><p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
</li>
<li><p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。  </p>
</li>
<li><p>B-Tree索引的一些限制：  </p>
<ol>
<li>如果不是按照索引的最左列开始查找，则无法使用索引。  </li>
<li>不能跳过索引中的列。  </li>
<li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。</li>
</ol>
</li>
</ul>
</li>
<li><p>哈希索引  </p>
<blockquote>
<p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：  </p>
</blockquote>
<ul>
<li>无法用于排序与分组；</li>
<li>只支持精确查找，无法用于部分查找和范围查找。</li>
<li>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</li>
</ul>
</li>
<li><p>空间数据索引</p>
<ul>
<li>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</li>
<li>必须使用 GIS 相关的函数来维护数据。</li>
</ul>
</li>
<li><p>全文索引</p>
<ul>
<li>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</li>
<li>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</li>
<li>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</li>
<li>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</li>
</ul>
</li>
</ol>
<h3 id="8-2-索引优化"><a href="#8-2-索引优化" class="headerlink" title="8.2 索引优化"></a>8.2 索引优化</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 独立的列</span><br><span class="line">2. 多列索引</span><br><span class="line">3. 前缀索引</span><br><span class="line">4. 索引列的顺序</span><br><span class="line">5. 覆盖索引</span><br><span class="line">6. 使用索引扫描来做排序</span><br><span class="line">7. 前缀压缩索引</span><br><span class="line">8. 冗余和重复索引</span><br><span class="line">9. 未使用的索引</span><br><span class="line">10. 索引和锁</span><br></pre></td></tr></table></figure>
<ol>
<li>独立的列<br>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。<br><code>SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</code></li>
<li>多列索引<br>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</li>
<li>索引列的顺序<br>让选择性最强的索引列放在前面。<br>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。  </li>
<li>前缀索引<br>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。前缀长度的选取需要根据索引选择性来确定。</li>
<li>聚簇索引<br>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中。因为无法同时把数据行存放在两个不同的地方，因此一个表只能有一个聚簇索引。  </li>
<li>覆盖索引 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8991cbca3854">覆盖索引</a><br>索引分为两种：聚簇索引和非聚簇索引。聚簇索引就是通过主键聚集数据，数据行存放在索引的叶子页中；而非聚簇索引的叶子页中存放的是主键值。<br>索引包含所有需要查询的字段的值。<br>具有以下优点：    <ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。  </li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。<br>explain的输出结果Extra字段为Using index时，能够触发索引覆盖。</li>
</ul>
</li>
</ol>
<h3 id="8-3-索引的优点"><a href="#8-3-索引的优点" class="headerlink" title="8.3 索引的优点"></a>8.3 索引的优点</h3><ol>
<li>大大减少了服务器需要扫描的数据行数。</li>
<li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li>
<li>将随机 I&#x2F;O 变为顺序 I&#x2F;O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li>
</ol>
<h3 id="8-4-索引的使用条件"><a href="#8-4-索引的使用条件" class="headerlink" title="8.4 索引的使用条件"></a>8.4 索引的使用条件</h3><ol>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>
<li>对于中到大型的表，索引就非常有效；</li>
<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>
</ol>
<h2 id="9-什么是主键"><a href="#9-什么是主键" class="headerlink" title="9. 什么是主键"></a>9. 什么是主键</h2><blockquote>
<p>主键（PRIMARY KEY），也称“主键约束”。<br>MySQL主键约束是一个列或者多个列的组合，其值能唯一地标识表中的每一行。<br>这样的一列或多列称为表的主键，通过它可以强制表的实体完整性。</p>
</blockquote>
<ol>
<li>主键规则：<ul>
<li>每个表有且仅有一个主键。</li>
<li>唯一性原则。主键值必须唯一地标识表中的每一行，且不能为NULL，即表中不可能存在两行数据有相同的主键值。</li>
<li>一个列名只能在复合主键列表中出现一次。</li>
<li>最小化原则。复合主键不能包含不必要的多余列。即当把复合主键的某一列删除后，如果剩下的列构成的主键仍然满足唯一性原则，那么这个复合主键是不正确的。</li>
</ul>
</li>
<li>主键和唯一索引的区别  <ul>
<li>主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。</li>
<li>主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。</li>
<li>唯一性索引列允许空值，而主键列不允许为空值。</li>
<li>主键列在创建时，已经默认为非空值 + 唯一索引了。</li>
<li>主键可以被其他表引用为外键，而唯一索引不能。</li>
<li>一个表最多只能创建一个主键，但可以创建多个唯一索引。</li>
<li>主键和唯一索引都可以有多列。</li>
<li>主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。<br><strong>总体来说：主键相当于一本书的页码，索引相当于书的目录。</strong></li>
</ul>
</li>
</ol>
<h2 id="10-Union和Union-All的区别"><a href="#10-Union和Union-All的区别" class="headerlink" title="10. Union和Union All的区别"></a>10. Union和Union All的区别</h2><ul>
<li>union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；</li>
<li>union All：对两个结果集进行并集操作，包括重复行，不进行排序；</li>
</ul>
<h2 id="11-in和exists区别"><a href="#11-in和exists区别" class="headerlink" title="11. in和exists区别"></a>11. in和exists区别</h2><ol>
<li>in和exists的区别：<ol>
<li>in有返回结果集，exists返回boolean</li>
<li>in的查询效率比exists要快</li>
<li>in先进行内查询在外查询，exists首先执行一次外部查询，在进行内部查询</li>
<li>IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。</li>
</ol>
</li>
<li>not in和not exists的区别：<ol>
<li>not in查询每条记录并没有用到索引。not exists根据索引查询，查询的效率远远高与not in查询的效率。</li>
</ol>
</li>
</ol>
<h2 id="12-MYSQL锁划分"><a href="#12-MYSQL锁划分" class="headerlink" title="12. MYSQL锁划分"></a>12. MYSQL锁划分</h2><ol>
<li>可以按照锁的粒度把数据库锁分为表级锁和行级锁。  <ol>
<li>表级锁<br> Mysql中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单 ，资源消耗也比较少，加锁快，不会出现死锁 。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。  </li>
<li>行级锁<br> Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 InnoDB支持的行级锁，包括如下几种。<br> 1. Record Lock: 对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；<br> 2. Gap Lock: 对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。<br> 3. Next-key Lock： 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。</li>
</ol>
</li>
<li>按照是否可写分类。  <ol>
<li>共享锁（s）<br> 共享锁（Share Locks，简记为S）又被称为读锁，其他用户可以并发读取数据，但任何事务都不能获取数据上的排他锁，直到已释放所有共享锁。<br> 共享锁(S锁)又称为读锁，若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。  </li>
<li>排他锁（X）：<br> 排它锁（(Exclusive lock,简记为X锁)）又称为写锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。在更新操作(INSERT、UPDATE 或 DELETE)过程中始终应用排它锁。</li>
</ol>
</li>
</ol>
<h2 id="13-读写分离"><a href="#13-读写分离" class="headerlink" title="13. 读写分离"></a>13. 读写分离</h2><ol>
<li>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。  </li>
<li>读写分离能提高性能的原因在于：  <ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；  </li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；  </li>
<li>增加冗余，提高可用性。<br><strong>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器</strong>。</li>
</ul>
</li>
</ol>
<h2 id="14-主从复制"><a href="#14-主从复制" class="headerlink" title="14. 主从复制"></a>14. 主从复制</h2><ol>
<li>主要涉及三个线程：binlog 线程、I&#x2F;O 线程和 SQL 线程。<ol>
<li>binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li>
<li>I&#x2F;O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</li>
<li>SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/08/%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fremont">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="有间栈">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 有间栈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/08/%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F2/" class="post-title-link" itemprop="url">最后一块石头的重量2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-08 12:13:26 / 修改时间：15:47:08" itemprop="dateCreated datePublished" datetime="2025-06-08T12:13:26+08:00">2025-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们需要将石头分成两堆，使得两堆石头的重量差最小。这可以转化为 ​<strong>​0&#x2F;1背包问题​</strong>​，即找到一个子集，使得其和尽可能接近 <code>总重量 / 2</code>。</p>
<h3 id="1-暴力解法-超时"><a href="#1-暴力解法-超时" class="headerlink" title="1. 暴力解法(超时)"></a>1. 暴力解法(超时)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stones == <span class="literal">null</span> || stones.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> stone: stones) &#123;</span><br><span class="line">            sum += stone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> stones.length;</span><br><span class="line">        backtrack(stones, sum, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] stone, <span class="type">int</span> sum, <span class="type">int</span> currentSum, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= stone.length) &#123;</span><br><span class="line">	        <span class="comment">// 记录两部分子数组 之差 的最小值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">otherSum</span> <span class="operator">=</span> sum - currentSum;</span><br><span class="line">            min = Math.min(min, Math.abs(otherSum - currentSum));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 两个选择：选index处的元素，或者不选</span></span><br><span class="line">        backtrack(stone, sum, currentSum + stone[index], index + <span class="number">1</span>);</span><br><span class="line">        backtrack(stone, sum, currentSum, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-带返回值的回溯，-向记忆化数组和dp的形式靠近"><a href="#2-带返回值的回溯，-向记忆化数组和dp的形式靠近" class="headerlink" title="2. 带返回值的回溯， 向记忆化数组和dp的形式靠近"></a>2. 带返回值的回溯， 向记忆化数组和dp的形式靠近</h3><h4 id="从index-0-递归"><a href="#从index-0-递归" class="headerlink" title="从index &#x3D; 0 递归"></a>从index &#x3D; 0 递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// int min = Integer.MAX_VALUE;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stones == <span class="literal">null</span> || stones.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> stone: stones) &#123;</span><br><span class="line">            sum += stone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// **从0开始递归**</span></span><br><span class="line">        <span class="keyword">return</span> backtrack(stones, sum, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前index数组，分为两个子序列，返回这两个子序列之差的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] stone, <span class="type">int</span> sum, <span class="type">int</span> currentSum, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="comment">// 返回index结尾的子数组 分为的两个子序列之差</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= stone.length) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">otherSum</span> <span class="operator">=</span> sum - currentSum;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(otherSum - currentSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递，两条路径，选择index，或不选择index</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">include</span> <span class="operator">=</span> backtrack(stone, sum, currentSum + stone[index], index + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">exclude</span> <span class="operator">=</span> backtrack(stone, sum, currentSum, index + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 归，返回选择index 和不选择 index 的最小值</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(include, exclude);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="从index-length-1开始递归"><a href="#从index-length-1开始递归" class="headerlink" title="从index &#x3D; length - 1开始递归"></a>从index &#x3D; length - 1开始递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// int min = Integer.MAX_VALUE;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stones == <span class="literal">null</span> || stones.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> stone: stones) &#123;</span><br><span class="line">            sum += stone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// **从length - 1 开始往下递归**</span></span><br><span class="line">        <span class="keyword">return</span> backtrack(stones, sum, <span class="number">0</span>, stones.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前index数组，分为两个子序列，返回这两个子序列之差的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] stone, <span class="type">int</span> sum, <span class="type">int</span> currentSum, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="comment">// 返回index结尾的子数组 分为的两个子序列之差</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">otherSum</span> <span class="operator">=</span> sum - currentSum;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(otherSum - currentSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递，两条路径，选择index，或不选择index</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">include</span> <span class="operator">=</span> backtrack(stone, sum, currentSum + stone[index], index - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">exclude</span> <span class="operator">=</span> backtrack(stone, sum, currentSum, index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 归，返回选择index 和不选择 index 的最小值</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(include, exclude);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-记忆化数组"><a href="#3-记忆化数组" class="headerlink" title="3. 记忆化数组"></a>3. 记忆化数组</h3><ul>
<li>注意：memo要定义成一个二维数组，而不能定义成<code>int[] memo = new int[len + 1];</code> 因为index不能唯一的确定一种状态，只有<ul>
<li>index：确定当前已经递归到哪个元素</li>
<li>currentSum：index之前的元素选择情况<br>  才能唯一的确定一种状态。</li>
</ul>
</li>
<li>可以看出，此时memo数组和dp的形式已经很像了，<code>memo[i][j]</code>表示的是以i结尾的子数组，分为两个子序列，这两个子序列差值的最小值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// int min = Integer.MAX_VALUE;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stones == <span class="literal">null</span> || stones.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> stone: stones) &#123;</span><br><span class="line">            sum += stone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> stones.length;</span><br><span class="line">        <span class="type">int</span>[][] memo = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; memo.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; memo[<span class="number">0</span>].length; j ++) &#123;</span><br><span class="line">                memo[i][j] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> backtrack(stones, sum, <span class="number">0</span>, stones.length - <span class="number">1</span>, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前index数组，分为两个子序列，返回这两个子序列之差的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] stone, <span class="type">int</span> sum, <span class="type">int</span> currentSum, <span class="type">int</span> index, <span class="type">int</span>[][] memo)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="comment">// 返回index结尾的子数组 分为的两个子序列之差</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">otherSum</span> <span class="operator">=</span> sum - currentSum;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(otherSum - currentSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (memo[index][currentSum] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[index][currentSum];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递，两条路径，选择index，或不选择index</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">include</span> <span class="operator">=</span> backtrack(stone, sum, currentSum + stone[index], index - <span class="number">1</span>, memo);</span><br><span class="line">        <span class="type">int</span> <span class="variable">exclude</span> <span class="operator">=</span> backtrack(stone, sum, currentSum, index - <span class="number">1</span>, memo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 归，返回选择index 和不选择 index 的最小值</span></span><br><span class="line">        memo[index][currentSum] = Math.min(include, exclude);</span><br><span class="line">        <span class="keyword">return</span> Math.min(include, exclude);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>dp</p>
<ol>
<li>**<code>dp</code> 定义：<ul>
<li><code>dp[i][j]</code> 表示前 <code>i</code> 个石头能否组成重量 <code>j</code>。</li>
</ul>
</li>
<li>​<strong>​初始化​</strong>​：<ul>
<li><code>dp[0][0] = true</code>（空子集可以组成重量 0）。</li>
<li>其他 <code>dp[0][j]</code> 默认为 <code>false</code>（Java 中布尔数组初始值为 <code>false</code>）。</li>
</ul>
</li>
<li>​<strong>​正确的状态转移​</strong>​：<ul>
<li>如果不选第 <code>i</code> 个石头，继承 <code>dp[i-1][j]</code>。</li>
<li>如果选第 <code>i</code> 个石头，检查 <code>dp[i-1][j - stones[i-1]]</code> 是否为 <code>true</code>。</li>
</ul>
</li>
<li>​<strong>​计算最终结果​</strong>​：<ul>
<li>从 <code>target</code> 反向遍历，找到最大的 <code>j</code> 使得 <code>dp[stones.length][j] = true</code>。</li>
<li>最小差值为 <code>sum - 2 * j</code>。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// int min = Integer.MAX_VALUE;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stones == <span class="literal">null</span> || stones.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> stone: stones) &#123;</span><br><span class="line">            sum += stone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> stones.length;</span><br><span class="line">        <span class="comment">// dp[i][j]定义： 以i结尾的子数组，是否可以组成重量j</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// init, 前0个石头可以组成重量0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= sum; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stones[i - <span class="number">1</span>] &lt;= j) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - stones[i - <span class="number">1</span>]];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSubSet</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到离target最近的j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target; j &gt;= <span class="number">0</span>; j --) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[len][j] == <span class="literal">true</span>) &#123;</span><br><span class="line">                maxSubSet = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> sum - <span class="number">2</span> * maxSubSet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始的思路是将dp定义成： <code>dp[i][j]</code> 为 ​<strong>​“以 <code>i</code> 结尾的子数组，分为两个子序列，这两个子序列差值的最小值”​</strong><br>不可以直接定义 <code>dp[i][j]</code> 为 ​<strong>​“以 <code>i</code> 结尾的子数组，分为两个子序列，这两个子序列差值的最小值”​</strong>​。原因如下：</p>
<ol>
<li><p>​<strong>​问题目标不匹配​</strong>​：</p>
<ul>
<li>我们需要的是 ​<strong>​全局最优解​</strong>​（整个数组分成两堆的最小差值），而不是 ​<strong>​以 <code>i</code> 结尾的子数组的局部最优解​</strong>​。</li>
<li>子问题的定义必须能递推到全局问题，而 <code>dp[i][j]</code> 的当前定义无法直接关联到最终的最小差值。</li>
</ul>
</li>
<li><p>​<strong>​状态转移难以设计​</strong>​：</p>
<ul>
<li>如果 <code>dp[i][j]</code> 表示以 <code>i</code> 结尾的子数组的最小差值，我们无法直接从 <code>dp[i-1][...]</code> 推导出 <code>dp[i][j]</code>，因为：<ul>
<li>新加入的石头 <code>stones[i]</code> 可以放入第一堆或第二堆，但差值的变化无法直接用 <code>dp[i-1][...]</code> 表示。</li>
<li>无法通过简单的 <code>Math.min</code> 或 <code>Math.max</code> 更新状态。</li>
</ul>
</li>
</ul>
</li>
<li><p>​<strong>​正确的 DP 定义​</strong>​：</p>
<ul>
<li>更合理的方式是 ​<strong>​将问题转化为背包问题​</strong>​：<ul>
<li><code>dp[i][j]</code> 表示 ​<strong>​前 <code>i</code> 个石头能否组成重量 <code>j</code>​</strong>​。</li>
<li>最终目标是找到最大的 <code>j &lt;= sum / 2</code> 使得 <code>dp[n][j] = true</code>，然后返回 <code>sum - 2 * j</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/08/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fremont">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="有间栈">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 有间栈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/08/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/" class="post-title-link" itemprop="url">dp-分割等和子集</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-08 12:07:07 / 修改时间：17:36:34" itemprop="dateCreated datePublished" datetime="2025-06-08T12:07:07+08:00">2025-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>621</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</span><br><span class="line"></span><br><span class="line">**示例 1：**</span><br><span class="line">输入：nums = [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br><span class="line"></span><br><span class="line">**示例 2：**</span><br><span class="line">输入：nums = [1,2,3,5]</span><br><span class="line">输出：false</span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>0-1背包问题<br>回溯 -&gt; 带返回值的回溯 -&gt; 记忆化数组 -&gt; dp<br>遍历数组nums，对每个元素都有两个选择：选或不选<br>转移方程： <code>dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]</code></p>
<p>不带返回值的回溯</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 成员变量记录是否找到解</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        backtrack(nums, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (found) <span class="keyword">return</span>; <span class="comment">// 提前终止，如果已经找到解</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span> || start &gt;= nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选择当前数字</span></span><br><span class="line">        backtrack(nums, target - nums[start], start + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 不选择当前数字</span></span><br><span class="line">        backtrack(nums, target, start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>带返回值的回溯</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> backtrack(nums, target, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span> || start &gt;= nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前数字的两个选择：选 或 不选</span></span><br><span class="line">        <span class="keyword">return</span> backtrack(nums, target, start + <span class="number">1</span>) || backtrack(nums, target - nums[start], start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记忆化数组<br>上述回溯算法会超时。所以加入记忆化数组优化<br>记忆化数组的定义要能唯一的确定一个状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        Boolean[][] memo = <span class="keyword">new</span> <span class="title class_">Boolean</span>[nums.length + <span class="number">1</span>][target + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> backtrack(nums, target, <span class="number">0</span>, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">int</span> start, Boolean[][] memo)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span> || start &gt;= nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[start][target] != <span class="literal">null</span>) <span class="keyword">return</span> memo[start][target];</span><br><span class="line">        memo[start][target] = backtrack(nums, target, start + <span class="number">1</span>, memo) || backtrack(nums, target - nums[start], start + <span class="number">1</span>, memo);</span><br><span class="line">        <span class="keyword">return</span> memo[start][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len + <span class="number">1</span>][target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= target; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/07/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fremont">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="有间栈">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 有间栈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/07/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">hexo博客新增和部署命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-07 21:50:20" itemprop="dateCreated datePublished" datetime="2025-06-07T21:50:20+08:00">2025-06-07</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>58</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo c == hexo clean      # 清除缓存  </span><br><span class="line">hexo g == hexo generate   # 生成静态文件</span><br><span class="line">hexo d == hexo deploy     # 部署到github中，更新网页端的内容</span><br><span class="line">hexo s == hexo server     # 通过启动本地服务器，预览文章效果</span><br><span class="line">hexo n == hexo new  </span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/07/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fremont">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="有间栈">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 有间栈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/07/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/" class="post-title-link" itemprop="url">汉明距离</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-07 12:07:07" itemprop="dateCreated datePublished" datetime="2025-06-07T12:07:07+08:00">2025-06-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-08 12:16:37" itemprop="dateModified" datetime="2025-06-08T12:16:37+08:00">2025-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>512</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<blockquote>
<p>位运算基础题</p>
</blockquote>
</blockquote>
<h3 id="1-java支持的位运算："><a href="#1-java支持的位运算：" class="headerlink" title="1. java支持的位运算："></a>1. java支持的位运算：</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&amp;：按位与。 同1为1，否则为0</span><br><span class="line"></span><br><span class="line">|：按位或。 只要有一个为1，就是1</span><br><span class="line"></span><br><span class="line">~：按位非。 取反</span><br><span class="line"></span><br><span class="line">^：按位异或。 相同为0，不同为1</span><br><span class="line"></span><br><span class="line">&lt;&lt;：左位移运算符。</span><br><span class="line">&gt;&gt; ：右位移运算符。</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;：无符号右移运算符。</span><br></pre></td></tr></table></figure>

<h3 id="2-工具函数"><a href="#2-工具函数" class="headerlink" title="2. 工具函数"></a>2. 工具函数</h3><p>lowbit函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int lowbit(int x) &#123; </span><br><span class="line">	return x &amp; -x; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>​<strong>​输入​</strong>​：任意整数 <code>x</code>（正、负均可）。</li>
<li>​<strong>​输出​</strong>​：<code>x</code> 的二进制表示中​<strong>​最低位的 1 及其后所有 0​</strong>​组成的数。</li>
</ul>
<h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><h5 id="1-统计二进制中-1-的个数​-​"><a href="#1-统计二进制中-1-的个数​-​" class="headerlink" title="1. 统计二进制中 1 的个数​**​"></a>1. 统计二进制中 1 的个数​**​</h5><p>通过循环减去 <code>lowbit(x)</code> 直到 <code>x</code> 为 0，统计操作次数即为 1 的个数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> x ^ y;</span><br><span class="line">	<span class="keyword">while</span> (tmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		tmp -= lowbit(tmp);</span><br><span class="line">		ans ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-​​树状数组（Fenwick-Tree）​​"><a href="#2-​​树状数组（Fenwick-Tree）​​" class="headerlink" title="2. ​​树状数组（Fenwick Tree）​​"></a>2. ​<strong>​树状数组（Fenwick Tree）​</strong>​</h5><ul>
<li><code>lowbit</code> 用于快速定位树状数组中需要更新或查询的节点。例如：</li>
<li>​<strong>​单点更新​</strong>​：从当前位置 <code>i</code> 开始，不断加上 <code>lowbit(i)</code>，直到超出数组范围。</li>
<li>​<strong>​前缀和查询​</strong>​：从当前位置 <code>i</code> 开始，不断减去 <code>lowbit(i)</code>，累加对应节点的值。</li>
</ul>
<h5 id="3-其他应用​-​"><a href="#3-其他应用​-​" class="headerlink" title="3. 其他应用​**​"></a>3. 其他应用​**​</h5><ul>
<li>​<strong>​判断 2 的幂​</strong>​：若 <code>lowbit(x) == x</code>，则 <code>x</code> 是 2 的幂（如 <code>x=8</code> 的二进制为 <code>1000</code>）。</li>
<li>​<strong>​区间合并与离散化​</strong>​：在算法题中用于快速处理区间边界（如 AcWing 802. 区间和问题）。</li>
</ul>
<h4 id="while-x-y-0-作用"><a href="#while-x-y-0-作用" class="headerlink" title="while ((x | y) !&#x3D; 0) 作用"></a>while ((x | y) !&#x3D; 0) 作用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((x | y) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x &amp; <span class="number">1</span>, b = y &amp; <span class="number">1</span>;</span><br><span class="line">            ans += a ^ b;</span><br><span class="line">            x &gt;&gt;= <span class="number">1</span>; y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>while ((x | y) != 0)</code> 的作用:<br>确保循环处理 <code>x</code> 和 <code>y</code> 的​<strong>​所有二进制位​</strong>​，直到所有位都被右移出（即 <code>x</code> 和 <code>y</code> 均变为 0）。</p>
<p>按位或运算的特性​​</p>
<ul>
<li>​<strong>​<code>x | y</code>​</strong>​ 会对 <code>x</code> 和 <code>y</code> 的每一位执行逻辑或操作：<ul>
<li>若 <code>x</code> 或 <code>y</code> 的某一位为 1，结果的该位为 1。</li>
<li>仅当 <code>x</code> 和 <code>y</code> 的所有位均为 0 时，结果才为 0。</li>
</ul>
</li>
<li>​<strong>​循环终止条件​</strong>​：当 <code>x</code> 和 <code>y</code> 的所有位均处理完毕（即均为 0）时，循环结束。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Fremont</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">51k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:06</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>

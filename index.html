<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="有间栈">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="有间栈">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fremont">
<meta property="article:tag" content="Java, Spring Boot, 算法，编程技术">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>有间栈</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">有间栈</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fremont</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/13/%E5%BE%85%E5%8A%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fremont">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="有间栈">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 有间栈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/13/%E5%BE%85%E5%8A%9E/" class="post-title-link" itemprop="url">待办</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-13 08:25:53 / 修改时间：08:26:12" itemprop="dateCreated datePublished" datetime="2025-06-13T08:25:53+08:00">2025-06-13</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/13/%E5%B8%B8%E7%94%A8%E7%9A%84%E9%94%81%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fremont">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="有间栈">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 有间栈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/13/%E5%B8%B8%E7%94%A8%E7%9A%84%E9%94%81%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">常用的锁实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-13 08:23:13 / 修改时间：08:25:07" itemprop="dateCreated datePublished" datetime="2025-06-13T08:23:13+08:00">2025-06-13</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/13/hot-100%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fremont">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="有间栈">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 有间栈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/13/hot-100%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">hot-100笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-13 08:22:29 / 修改时间：08:24:42" itemprop="dateCreated datePublished" datetime="2025-06-13T08:22:29+08:00">2025-06-13</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/13/%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E+%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fremont">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="有间栈">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 有间栈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/13/%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E+%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">任务执行引擎+线程池动态配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-13 08:21:11 / 修改时间：08:24:16" itemprop="dateCreated datePublished" datetime="2025-06-13T08:21:11+08:00">2025-06-13</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/13/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E5%AE%B9%E9%94%99%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fremont">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="有间栈">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 有间栈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/13/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E5%AE%B9%E9%94%99%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">支付系统容错设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-13 08:19:14 / 修改时间：08:24:32" itemprop="dateCreated datePublished" datetime="2025-06-13T08:19:14+08:00">2025-06-13</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/13/%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E9%A2%91%E6%8E%A7%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fremont">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="有间栈">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 有间栈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/13/%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E9%A2%91%E6%8E%A7%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">基于redis的频控模块设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-13 08:19:11 / 修改时间：08:24:52" itemprop="dateCreated datePublished" datetime="2025-06-13T08:19:11+08:00">2025-06-13</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/13/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fremont">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="有间栈">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 有间栈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/13/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">适配器模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-13 08:19:08 / 修改时间：08:25:19" itemprop="dateCreated datePublished" datetime="2025-06-13T08:19:08+08:00">2025-06-13</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/11/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E9%97%AE%E9%A2%98%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fremont">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="有间栈">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 有间栈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/11/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E9%97%AE%E9%A2%98%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD/" class="post-title-link" itemprop="url">股票买卖问题一网打尽</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-11 08:41:38" itemprop="dateCreated datePublished" datetime="2025-06-11T08:41:38+08:00">2025-06-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-13 08:12:55" itemprop="dateModified" datetime="2025-06-13T08:12:55+08:00">2025-06-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>![[Pasted image 20250609222711.png]]</p>
<h2 id="1-基础题-：121-买卖股票的最佳时机"><a href="#1-基础题-：121-买卖股票的最佳时机" class="headerlink" title="1. 基础题 ：121 - 买卖股票的最佳时机"></a>1. 基础题 ：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121 - 买卖股票的最佳时机</a></h2><blockquote>
<p>题目描述：给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。<br>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
</blockquote>
<p><strong>重点：只能买卖一次</strong></p>
<ol>
<li><p>dp数组的定义</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">或</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">前一种方式，dp[<span class="number">0</span>][i]表示第<span class="number">0</span>天，即未开始的状态。真正有意义的是[<span class="number">1</span>, i]  </span><br><span class="line">后一种方式</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">// dp设置为len + 1，是为了将dp[0]定义为第0天</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 第0天 不持有股票，利润为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第0天 不可能持有股票，用最小值表示这种不可能</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = - Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i ++) &#123;</span><br><span class="line">	        <span class="comment">// 1. 第i天 不持有股票</span></span><br><span class="line">	        <span class="comment">// 前一天就不持有</span></span><br><span class="line">	        <span class="comment">// 前一天持有，今天卖了</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line">			<span class="comment">// 2. 第i天 持有股票</span></span><br><span class="line">	        <span class="comment">// 前一天就 持有股票，今天不变</span></span><br><span class="line">	        <span class="comment">// 前一天未持有，今天买入，由于只有一次机会，所以不带dp[i - 1][0]</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="122-买卖股票的最佳时机2"><a href="#122-买卖股票的最佳时机2" class="headerlink" title="122- 买卖股票的最佳时机2"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122- 买卖股票的最佳时机2</a></h2><blockquote>
<p>题目描述：给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。<br>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。<br>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
</blockquote>
<p><strong>重点：可以买卖无限次</strong></p>
<ol>
<li>dp数组的定义</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = - Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i ++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="123-买卖股票的最佳时机3"><a href="#123-买卖股票的最佳时机3" class="headerlink" title="123- 买卖股票的最佳时机3"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">123- 买卖股票的最佳时机3</a></h2><blockquote>
<p>题目描述：给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。<br>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
</blockquote>
<p><strong>重点：限定次数为2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxK</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// dp[i][k][0]：第 i 天结束时，最多完成 k 笔交易，且不持有股票的最大利润。</span></span><br><span class="line">        <span class="comment">// dp[i][k][1]：第 i 天结束时，最多完成 k 笔交易，且持有股票的最大利润。</span></span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>][maxK + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt;= maxK; k ++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">1</span>] = - Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没必要初始化 k 为 0 时的case，因为k = 0 肯定不是答案。所以下面的遍历是从k = 1开始的，即至少要完成一次交易。</span></span><br><span class="line">        <span class="comment">// for (int i = 1; i &lt;= len; i ++) &#123;</span></span><br><span class="line">        <span class="comment">//     dp[i][0][0] = 0;</span></span><br><span class="line">        <span class="comment">//     dp[i][0][1] = - Integer.MAX_VALUE;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= maxK; k ++) &#123;</span><br><span class="line">                dp[i][k][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">0</span>], dp[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line">                <span class="comment">// 在买入时扣减交易次数</span></span><br><span class="line">                dp[i][k][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">1</span>], dp[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len][maxK][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机4"><a href="#买卖股票的最佳时机4" class="headerlink" title="买卖股票的最佳时机4"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">买卖股票的最佳时机4</a></h2><blockquote>
<p>题目描述<br>给你一个整数数组 <code>prices</code> 和一个整数 <code>k</code> ，其中 <code>prices[i]</code> 是某支给定的股票在第 <code>i</code> 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。<br>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
</blockquote>
<p><strong>重点：限定次数为k</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> maxK, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>][maxK + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= maxK; i ++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">1</span>] = - Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= maxK; k ++) &#123;</span><br><span class="line">                dp[i][k][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">0</span>], dp[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line">                dp[i][k][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">1</span>], dp[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len][maxK][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3573-买卖股票的最佳时机5"><a href="#3573-买卖股票的最佳时机5" class="headerlink" title="3573 - 买卖股票的最佳时机5"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-v/description/">3573 - 买卖股票的最佳时机5</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">你最多可以进行 `k` 笔交易，每笔交易可以是以下任一类型：</span><br><span class="line"></span><br><span class="line">- **普通交易**：在第 `i` 天买入，然后在之后的第 `j` 天卖出，其中 `i &lt; j`。你的利润是 `prices[j] - prices[i]`。</span><br><span class="line">    </span><br><span class="line">- **做空交易**：在第 `i` 天卖出，然后在之后的第 `j` 天买回，其中 `i &lt; j`。你的利润是 `prices[i] - prices[j]`。</span><br><span class="line">**注意**：你必须在开始下一笔交易之前完成当前交易。此外，你不能在已经进行买入或卖出操作的同一天再次进行买入或卖出操作。</span><br><span class="line"></span><br><span class="line">通过进行 **最多** `k` 笔交易，返回你可以获得的最大总利润。</span><br></pre></td></tr></table></figure>




<h2 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714-买卖股票的最佳时机含手续费"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714-买卖股票的最佳时机含手续费</a></h2><blockquote>
<p>题目描述<br>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。<br>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。<br>返回获得利润的最大值。<br>**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
</blockquote>
<p>如果dp数组定义为<code>int[][] dp = new int[len + 1][2];</code> 而不是<code>int[][] dp = new int[len][2];</code>时，base不同<br>前者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[0][0] = 0; // 第 0 天不持有股票，收益为 0</span><br><span class="line">dp[0][1] = -Integer.MAX_VALUE; // 第 0 天不可能持有股票，设为负无穷</span><br></pre></td></tr></table></figure>
<p>后者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[0][0] = 0; // 第 0 天不持有股票，收益为 0</span><br><span class="line">dp[0][1] = -prices[0]; 第 0 天买入股票，收益为 - prices[0]</span><br></pre></td></tr></table></figure>
<p>此间差别在前面影响不大，但这题会有影响，因为当<code>dp[0][1] = -Integer.MAX_VALUE;</code>时，装填转移方程的组成之一 <code>dp[i - 1][1] + prices[i - 1] - fee</code> 可能越界，因此多了一个<code> dp[i - 1][1] == - Integer.MAX_VALUE</code>判断条件。<br>对于第一种dp数组定义，<code>dp[0][i]</code>的含义类似哑节点，含义是在正式开始前的初始化，可以把他想象成<code>dp[-1][i]</code><br>第二种dp数组定义，<code>dp[0][i]</code>标识的其实就是第一天，这个0，指的是数组中的下标为0的元素。<br>至于哪种好理解，看个人喜好吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="comment">// int len = prices.length;</span></span><br><span class="line">        <span class="comment">// if (prices == null || prices.length == 0) &#123;</span></span><br><span class="line">        <span class="comment">//     return 0;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// int[][] dp = new int[len + 1][2];</span></span><br><span class="line">        <span class="comment">// dp[0][0] = 0;</span></span><br><span class="line">        <span class="comment">// dp[0][1] = - Integer.MAX_VALUE;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (int i = 1; i &lt;= len; i ++) &#123;</span></span><br><span class="line">        <span class="comment">//     dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i - 1] - fee);</span></span><br><span class="line">        <span class="comment">//     dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return dp[len][0];</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="literal">null</span> || len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第 0 天不持有股票，收益为 0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -Integer.MAX_VALUE; <span class="comment">// 第 0 天不可能持有股票，设为负无穷</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="comment">// 第 i 天不持有股票</span></span><br><span class="line">            <span class="comment">// 后半部分可能越界  就因为这个，最好把dp定义成int[][] dp = new int[len][2];</span></span><br><span class="line"></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] == - Integer.MAX_VALUE ? - Integer.MAX_VALUE : (dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>] - fee));</span><br><span class="line">            <span class="comment">// 第 i 天持有股票</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> dp[len][<span class="number">0</span>]; <span class="comment">// 最后一天不持有股票的最大收益</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="309-买卖股票的最佳时机含冷冻期"><a href="#309-买卖股票的最佳时机含冷冻期" class="headerlink" title="309- 买卖股票的最佳时机含冷冻期"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">309- 买卖股票的最佳时机含冷冻期</a></h2><blockquote>
<p>题目描述<br>给定一个整数数组<code>prices</code>，其中第  <code>prices[i]</code> 表示第 <code>_i_</code> 天的股票价格 。​<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
</blockquote>
<p><strong>重点：除不持有股票、持有股票之外，还多了冷冻期这个状态</strong></p>
<ol>
<li>未持有可能由 未持有 + 冷冻期 转换而来</li>
<li>持有 可能由 持有 +买入 转换而来</li>
<li>冷冻 只能由 前一天持有 并卖出 转换而来<br>由上面三个条件可推出对应的状态转移方程<br>其中 未持有的转换状态最有迷惑性，要想清楚，未持有状态不可能由持有状态直接转换过来。<br>最后的结果是<br><code>Math.max(dp[len][0], dp[len][1]); // 需要比较冷冻期和不持有股票的收</code><br>即要取未持有和冷冻状态的最大值。这两种情况手里都没有股票了，都可能是答案</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第 0 天不持有股票，收益为 0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -Integer.MAX_VALUE; <span class="comment">// 第 0 天不可能处于冷冻期</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = -Integer.MAX_VALUE; <span class="comment">// 第 0 天不可能持有股票</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="comment">// 第 i 天不持有股票</span></span><br><span class="line">            <span class="comment">// 前一天 未持有</span></span><br><span class="line">            <span class="comment">// 前一天为冷冻期</span></span><br><span class="line">            <span class="comment">// 前一天持有并卖出，将变为冷冻状态，所以未持有状态不能由持有状态直接转换而来</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 第 i 天处于冷冻期</span></span><br><span class="line">            <span class="comment">// 冷冻期 只能由 前一天持有并卖出转换而来</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>] + prices[i - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 第 i 天持有股票</span></span><br><span class="line">            <span class="comment">// 前一天就持有</span></span><br><span class="line">            <span class="comment">// 前一天未持有，今天买入</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 返回最后一天不持有股票的最大收益</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[len][<span class="number">0</span>], dp[len][<span class="number">1</span>]); <span class="comment">// 需要比较冷冻期和不持有股票的收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/08/mysql%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fremont">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="有间栈">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 有间栈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/08/mysql%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">mysql基础语法-历史学习记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-08 22:41:42 / 修改时间：22:43:42" itemprop="dateCreated datePublished" datetime="2025-06-08T22:41:42+08:00">2025-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">历史学习记录</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>46 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、DQL"><a href="#一、DQL" class="headerlink" title="一、DQL"></a>一、DQL</h2><p>data query language  数据查询语言</p>
<h3 id="1-基础查询"><a href="#1-基础查询" class="headerlink" title="1. 基础查询"></a>1. 基础查询</h3><ul>
<li>语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 查询列表 from 表名;</span><br></pre></td></tr></table></figure>
<ul>
<li>特点：<br><br>1、查询列表可以是：表中的字段、常量值、表达式、函数<br/><br>2、查询的结果是一个虚拟的表</li>
</ul>
<ol>
<li>选中特定的数据库：<br><code>use employees;</code></li>
<li>查询表中的单个字段：<br><code>select last_name from employees;</code></li>
<li>查询表中的多个字段：<br><code>select last_name,salary,email from employees;</code></li>
<li>查询表中的所有字段：<br><code>select * from employees;</code></li>
<li>查询常量值：<br><code>select 100;</code><br><code>select &#39;join&#39;;</code></li>
<li>查询表达式：<br><code>select 100*98;</code></li>
<li>查询函数：<br><code>select version();</code></li>
<li>起别名</li>
</ol>
<ul>
<li>便于理解</li>
<li>如果要查询的字段有重名的情况，可以使用别名可以区分开来<br>方式一：使用as<br><code>select 100% 98 as 结果;</code><br><code>select last_name as 姓,first_name as 名 from employees;</code><br>方式二：省略as,使用空格<br><code>select last_name 姓,first_name 名 from employees;</code><br>案例：<br><code>select salary as &quot;out put&quot; from employees;</code></li>
</ul>
<ol start="9">
<li>去重<ul>
<li>案例：查询员工表中涉及到的所有的部门编号<br>  <code>select department_id form employees;</code>  不去重<br>  <code>select distinct department_id form employees;</code>　　去重</li>
</ul>
</li>
<li>+号的作用<blockquote>
<p>java中的＋号：<br></p>
</blockquote>
<ol>
<li>运算符，两个操作数都为数值型;</br></li>
<li>连接符，只要与一个操作数为字符串;</br><blockquote>
<p>mysql 中的＋号</br><br>仅仅只有运算符的功能</br><br><code>select 100+90;</code>　两个操作数都是数值型，则做加法运算</br><br>｀select ‘123’+90;｀ 其中一方为字符型，试图将字符型数值转换为数值型，如果转换成功，则继续做加法运算；（213）</br><br>｀select ‘join’ + 90;｀ 如果转换失败，则将字符型数值转换为０；　（90）</br><br><code>select null+10;</code> 只要其中一方为null,则结果肯定为null</br></p>
</blockquote>
</li>
</ol>
</li>
</ol>
<ul>
<li>案例：查询员工名和姓连接成一个字段，并显示为姓名; </br><br>  <code>select concat(last_name,first_name) as 姓名 from empolyees;</code></li>
</ul>
<h3 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2. 条件查询"></a>2. 条件查询</h3><ul>
<li>语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	查询列表</span><br><span class="line">from</span><br><span class="line">	表名</span><br><span class="line">where</span><br><span class="line">	筛选条件;</span><br></pre></td></tr></table></figure>
<ul>
<li>分类：<ol>
<li>按条件表达式筛选<br><br> 条件运算符：&gt; &lt; &#x3D; !&#x3D; &gt;&#x3D; &lt;&#x3D;  &lt;&gt;</li>
<li>按逻辑表达式筛选<br><br> 逻辑运算符：&amp;&amp; || !<br>     and or not</li>
<li>模糊查询：<br><br> like <br><br> between and <br><br> in <br/><br> is null <br/></li>
</ol>
</li>
</ul>
<h4 id="1-按条件表达式筛选"><a href="#1-按条件表达式筛选" class="headerlink" title="1. 按条件表达式筛选"></a>1. 按条件表达式筛选</h4><p>案例１：查询工资 &gt; 12000的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	*</span><br><span class="line">from</span><br><span class="line">	employees 	</span><br><span class="line">where</span><br><span class="line">	salary &gt; 12000;</span><br></pre></td></tr></table></figure>
<p>案例２：查询部门编号不等于90号的员工名和部门编号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	last_time,</span><br><span class="line">	department_id</span><br><span class="line">from</span><br><span class="line">	employees</span><br><span class="line">where</span><br><span class="line">	department_id &lt;&gt; 90;</span><br></pre></td></tr></table></figure>
<h4 id="2-按逻辑表达式筛选"><a href="#2-按逻辑表达式筛选" class="headerlink" title="2. 按逻辑表达式筛选"></a>2. 按逻辑表达式筛选</h4><p>案例１：查询工资ｚ在10000和20000之间的员工名、工资以及奖金</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	last_name,</span><br><span class="line">	salary,</span><br><span class="line">	commission_pct</span><br><span class="line">from</span><br><span class="line">	employees</span><br><span class="line">where</span><br><span class="line">	salary &gt;= 10000 and salary &lt;= 20000;</span><br></pre></td></tr></table></figure>
<p>案例２：查询部门编号不是在90到110之间，或者工资高于15000的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	*</span><br><span class="line">from</span><br><span class="line">	employees</span><br><span class="line">where</span><br><span class="line">	not(department_id &gt;=90 and department &lt;=110) or salary&gt;15000;</span><br></pre></td></tr></table></figure>
<h4 id="3-模糊查询"><a href="#3-模糊查询" class="headerlink" title="3. 模糊查询"></a>3. 模糊查询</h4><ul>
<li>like <br><br>  特点：<br><ol>
<li>一般和通配符搭配使用<br><ul>
<li>%:　任意多个字符，包含０个字符<br></li>
<li>_：任意单个字符</li>
</ul>
</li>
</ol>
</li>
<li>between and <br><ol>
<li>可以提高语句的简洁度； <br></li>
<li>包含边界值；<br></li>
<li>between 后面的值 要 &lt;&#x3D; and后面的值</li>
</ol>
</li>
<li>in <br><ul>
<li>含义：判断某字段的值是否属于in列表中的一项</li>
<li>特点：<ol>
<li>提高语句简洁度；<br></li>
<li>in列表的值类型必须一致或兼容;<br></li>
</ol>
</li>
</ul>
</li>
<li>is null <br><ul>
<li>&#x3D; 或者&lt;&gt;不能用于判断null值</li>
<li>判断null要用is null 和 is not null;</li>
</ul>
</li>
<li>is not null <br></li>
</ul>
<ol>
<li>like <br><br> 案例１：查询员工名中包含字符ａ的员工信息 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	*</span><br><span class="line">from</span><br><span class="line">	employees</span><br><span class="line">where</span><br><span class="line">	last_name like　&#x27;%a%&#x27;</span><br></pre></td></tr></table></figure>
 案例２：查询员工名中第三个字符为ｅ，第五个字符为ａ的员工名和工资 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	last_name,</span><br><span class="line">	salary</span><br><span class="line">where</span><br><span class="line">	last_name like &#x27;__e_a%&#x27;;</span><br></pre></td></tr></table></figure>
 案例3：查询员工名中第二个字符为_的员工名(escape转义) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	last_name</span><br><span class="line">from</span><br><span class="line">	employees</span><br><span class="line">where</span><br><span class="line">	last_name like &#x27;_$_%&#x27; escape &#x27;$&#x27;;</span><br></pre></td></tr></table></figure></li>
<li>between and <br><br> 案例一：查询员工编号在100到120之间的员工信息 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	*</span><br><span class="line">from</span><br><span class="line">	employees</span><br><span class="line">where</span><br><span class="line">	employee_id &gt;= 100 and employees &lt;=120;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	*</span><br><span class="line">from</span><br><span class="line">	employees</span><br><span class="line">where</span><br><span class="line">	employee_id between 100 and 120;</span><br></pre></td></tr></table></figure></li>
<li>in <br><br> 案例1：查询员工的工种编号是IT_PROG、AD_VP、AD_PRES中的一个的员工名和公众编号 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	last_name,</span><br><span class="line">	job_id</span><br><span class="line">from</span><br><span class="line">	employees</span><br><span class="line">where</span><br><span class="line">	job_id=&#x27;IT_PROG&#x27; or job_id=&#x27;AD_VP&#x27; or job_id=&#x27;AD_PRES&#x27;;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	last_name,</span><br><span class="line">	job_id</span><br><span class="line">from</span><br><span class="line">	employees</span><br><span class="line">where</span><br><span class="line">	job_id in (&#x27;IT_PROG&#x27;,&#x27;AD_VP&#x27;,&#x27;AD_PRES&#x27;);</span><br></pre></td></tr></table></figure></li>
<li>is null (等于号不能判断null)<br><br> 案例1：查询没有奖金率的员工名和奖金率；<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line">from</span><br><span class="line">	employees</span><br><span class="line">where</span><br><span class="line">	commission_pct is null;</span><br></pre></td></tr></table></figure>
 案例2：查询有奖金率的员工名和奖金率；<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line">from</span><br><span class="line">	employees</span><br><span class="line">where</span><br><span class="line">	commission_pct is not null;</span><br></pre></td></tr></table></figure></li>
<li>安全等于  &lt;&#x3D;&gt; <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line">from</span><br><span class="line">	employees</span><br><span class="line">where</span><br><span class="line">	commission_pct &lt;=&gt; null;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	last_name,</span><br><span class="line">	salary</span><br><span class="line">from</span><br><span class="line">	employees</span><br><span class="line">where</span><br><span class="line">	salary &lt;=&gt; 12000;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>is null : 仅仅可以判断null值；<br><br>&lt;&#x3D;&gt; ：  既可以判断null值，又可以判断普通的数值；</p>
</blockquote>
</li>
</ol>
<p>ifnull(exp1,exp2): 如果表达式1的值为null，就替换为表达式2的值</p>
<h3 id="3-排序查询"><a href="#3-排序查询" class="headerlink" title="3. 排序查询"></a>3. 排序查询</h3><ul>
<li>语法：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表</span><br><span class="line">[where 筛选条件]</span><br><span class="line">order by 排序列表 [asc|desc];</span><br></pre></td></tr></table></figure></li>
<li>案例1：查询员工信息，要求工资从高到低排序 <br><br>  <code>SELECT * FROM employees ORDER BY salary DESC;</code></li>
<li>特点：<ol>
<li>asc代表升序，desc代表降序；<br></li>
<li>如果不写，默认升序；<br></li>
<li>order by 子句可以支持单个字段、多个字段、表达式、函数、别名；<br></li>
<li><strong>order by 子句一般放在查询语句的最后面，limit子句除外;</strong> <br></li>
</ol>
</li>
<li>案例2：查询部门编号&gt;&#x3D;90的员工信息，按入职时间的先后进行排序；<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from employees</span><br><span class="line">where department_id &gt;= 90</span><br><span class="line">order by hireday asc;</span><br></pre></td></tr></table></figure></li>
<li>案例3：按年薪的高低显示员工的信息和年薪【按表达式排序】  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *, salary*12*(1 + IFNULL(commission_pct,0)) 年薪</span><br><span class="line">from employees</span><br><span class="line">order by salary*12*(1 + IFNULL(commission_pct,0)) desc;</span><br></pre></td></tr></table></figure></li>
<li>案例4：按年薪的高低显示员工的信息和年薪【按别名排序】  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *, salary*12*(1 + IFNULL(commission_pct,0)) 年薪</span><br><span class="line">from employees</span><br><span class="line">order by 年薪 desc;</span><br></pre></td></tr></table></figure></li>
<li>案例5：按姓名的长度显示员工的姓名和工资【按函数排序】  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select LENGTH(last_name) 姓名长度, last_name,salary</span><br><span class="line">from employees</span><br><span class="line">order by LENGTH(last_name) desc;</span><br></pre></td></tr></table></figure></li>
<li>案例6：查询员工信息，要求先按工资升序排序，再按员工编号降序排序【按多个字段排序】(也就是先按工资排序，如果有俩人工资一样，按员工编号排序)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from employees</span><br><span class="line">order by salary asc,employee_id desc;</span><br></pre></td></tr></table></figure>
测试1：查询员工的姓名和部门号和年薪，按年薪降序，按姓名升序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select last_name,department_id,salary*12*(1+ifnull(commission_pct,0)) 年薪</span><br><span class="line">from employees</span><br><span class="line">order by 年薪 asc,last_name desc;</span><br></pre></td></tr></table></figure>
<p>测试2：选择工资不在8000到17000的员工的姓名和工资，按工资降序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select last_name,salary</span><br><span class="line">from employees</span><br><span class="line">where not(salary &gt;= 8000 and salary &lt;= 17000)</span><br><span class="line">order by salary desc;</span><br></pre></td></tr></table></figure>
<p>测试3：查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from employees</span><br><span class="line">where email like(&#x27;%e%&#x27;)</span><br><span class="line">order by LENGTH(email) desc,department_id asc;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-常见函数"><a href="#4-常见函数" class="headerlink" title="4. 常见函数"></a>4. 常见函数</h3><ul>
<li>功能：类似于java的方法，将我们的一组逻辑语句封装在方法体中，对外暴露方法名</li>
<li>好处：<ol>
<li>隐藏了实现细节；<br></li>
<li>提高了代码的重用性;<br></li>
</ol>
</li>
<li>调用：<br><br>  <code>select 函数名（参数） 【from 表】；</code></li>
<li>分类：<ol>
<li>单行函数<ul>
<li>concat、length、ifnull等</li>
</ul>
</li>
<li>分组函数<ul>
<li>功能：做统计使用，又称为统计函数、聚合函数、组函数；</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="1-单行函数"><a href="#1-单行函数" class="headerlink" title="1. 单行函数"></a>1. 单行函数</h4><h5 id="1-字符函数"><a href="#1-字符函数" class="headerlink" title="1. 字符函数"></a>1. 字符函数</h5><ol>
<li>length：获取参数值的字节个数；</li>
<li>concat：拼接字符串；<br><br> <code>select concat(last_name,&#39;_&#39;,first_name) 姓名 from employees;</code></li>
<li>upper\lower：大小写；<br><br> <code>select UPPER(&#39;john&#39;)</code><br> <code>select concat(UPPER(last_name),&#39;_&#39;,LOWER(first_name)) 姓名 from employees;</code></li>
<li>substr、substring：截取字符串；<br><br><strong>注意：索引从1开始</strong><br><ul>
<li>截取从指定索引处后面的所有字符 <br/>(陆展元)<br>  <code>select substr(&#39;李莫愁爱上了陆展元&#39;,7) out_put</code></li>
<li>截取从指定索引处指定字符长度的字符 <br/>（李莫愁）<br>  <code>select substr(&#39;李莫愁爱上了陆展元&#39;,1,3) out_put</code>  </li>
<li>案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select concat(upper(substr(last_name,1,1)),&#x27;_&#x27;,lower(substr(last_name,2)))</span><br><span class="line">from</span><br><span class="line">employees;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>instr：返回子串第一次出现的索引，如果找不到返回0;<br><br> <code>select instr(&#39;杨不殷六侠&#39;，殷六侠) as out_put;</code>  (返回3)</li>
<li>trim：去掉前后空格；<br><br> <code>selelct trim(&#39;    张翠山    &#39;) as out_put;</code><br> <code>select trim(&#39;a&#39; from &#39;aaaa张aaaaa翠山aaaaaa&#39;) as out_put;</code>(输出张aaaaa翠山)</li>
<li>lpad：左填充，用指定的字符实现指定长度；<br> <code>select lpad(&#39;殷素素&#39;,5,&#39;*&#39;) as out_put;</code> (**殷素素)</li>
<li>rpad：右填充，用指定的字符实现指定长度；</li>
<li>replace 替换<br> <code>select replace(</code>张无忌爱周芷若<code>,</code>周芷若<code>,</code>赵敏<code>) as out_put;</code>(张无忌爱赵敏)</li>
</ol>
<h5 id="2-数学函数"><a href="#2-数学函数" class="headerlink" title="2.数学函数"></a>2.数学函数</h5><ol>
<li>round：四舍五入；<br><br> <code>select round(-1.55);</code>(-2)<br><br> <code>select round(1.567,2);</code>(小数点后保留两位数字；1.57)<br></li>
<li>ceil：向上取整,返回大于等于该参数的最小整数;<br><br> <code>select ceil(1.02);</code>(2)<br></li>
<li>floor：向下取整,返回小于等于该参数的最大整数;<br><br> <code>select ceil(-9.9);</code>(-10)<br></li>
<li>truncate：截断;<br><br> <code>select truncate(1.6999,1)</code>(1.6) <br></li>
<li>mod：取余 <br><br> <code>select mod(10,-3)</code></li>
</ol>
<h5 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="3.日期函数"></a>3.日期函数</h5><ol>
<li>now：返回当前系统日期 + 时间；<br><br> <code>select now();</code></li>
<li>curdate 返回当前日期，不包含时间；<br><br> <code>select curdate();</code></li>
<li>curtime 返回当前时间，不包含日期；<br><br> <code>select curtime();</code></li>
<li>可以获取指定的部分，年、月、日、小时、分钟、秒；<br> <code>select year(now()) 年;</code>（2020）<br><br> <code>select year(&#39;1998-1-1&#39;) 年；</code>（1998）<br><br> <code>select month(now()) 月;</code>(九月)<br><br> <code>select monthname(now()) 月；</code> (September) <br></li>
<li>str_to_date：将日期格式的字符转换成指定格式的日期;<br><br> <code>STR_TO_DATE(&#39;9-13-1999&#39;,&#39;%m-%d-%Y&#39;);</code> (1999-09-13) <br></li>
<li>date_format：将日期转换成字符；<br><br> <code>DATE_FORMAT(&#39;2018/6/6&#39;,&#39;%Y年%m月%d日&#39;)；</code> (2018年6月6日) <br></li>
</ol>
<h5 id="4-其它函数"><a href="#4-其它函数" class="headerlink" title="4.其它函数"></a>4.其它函数</h5><ol>
<li><code>select version();</code> 显示版本号; <br></li>
<li><code>select database();</code> 查看当前的库<br></li>
<li><code>select user();</code> 代表当前用户；<br></li>
</ol>
<h5 id="5-流程控制函数"><a href="#5-流程控制函数" class="headerlink" title="5.流程控制函数"></a>5.流程控制函数</h5><ol>
<li>if函数： if else 的效果；<br><br> <code>select IF(exp1,exp2,exp3)</code> exp1成立的话返回exp2的值，否则返回exp3的值;<br></li>
<li>case函数：<ul>
<li>使用1：switch case的效果：<br><ol>
<li>语法： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case 要判断的字段或表达式</span><br><span class="line">when 常量1 then 要显示的值1或语句1；</span><br><span class="line">when 常量2 then 要显示的值2或语句2；</span><br><span class="line">...</span><br><span class="line">else 要显示的值n或语句n；</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>案例：查询员工的工资，要去部门号&#x3D;30，现实的工资为1.1倍；部门号&#x3D;40,1.2倍，…其他部门，原工资；<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select salary 原始工资，department_id,</span><br><span class="line">case department_id</span><br><span class="line">when 30 then salary*1.1</span><br><span class="line">when 40 then salary*1.2</span><br><span class="line">when 50 then salary*1.3</span><br><span class="line">else salary</span><br><span class="line">end as 新工资</span><br><span class="line">from employees;</span><br></pre></td></tr></table></figure>
 (结果是三列：原始工资、department_id、新工资) <br></li>
</ol>
</li>
<li>使用2：类似于多重if  <br><ol>
<li>语法： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case</span><br><span class="line">when 条件1 then 要显示的值1或语句1</span><br><span class="line">when 条件2 then 要显示的值2或语句2</span><br><span class="line">...</span><br><span class="line">else 要显示的值n或语句n</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>案例：查询员工的工资情况：如果工资&gt;20000，显示A级别；大于15000，显示B级别；大于10000，显示C级别；否则D级别；<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select salary,</span><br><span class="line">case</span><br><span class="line">when salary&gt;20000 then &#x27;A&#x27;</span><br><span class="line">when salary&gt;15000 then &#x27;B</span><br><span class="line">when salary&gt;10000 then &#x27;C</span><br><span class="line">else &#x27;D&#x27;</span><br><span class="line">end as 工资级别</span><br><span class="line">from employees;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
</ol>
<p>练习：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select(now());</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id,last_name,salary,salary*1.2 as &quot;new salary&quot;</span><br><span class="line">from employees;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select last_name,LENGTH(last_name) 姓名长度</span><br><span class="line">from employees</span><br><span class="line">order by substr(lastname,1,1);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select job,</span><br><span class="line">case job</span><br><span class="line">when &#x27;AD_PROG&#x27; then &#x27;A&#x27;</span><br><span class="line">when &#x27;ST_MAN&#x27; then &#x27;B&#x27;</span><br><span class="line">when &#x27;IT_PROG&#x27; then &#x27;C&#x27;</span><br><span class="line">else &#x27;D&#x27;</span><br><span class="line">end as grade</span><br><span class="line">from employees;</span><br></pre></td></tr></table></figure>

<h4 id="2-分组函数"><a href="#2-分组函数" class="headerlink" title="2.分组函数"></a>2.分组函数</h4><ul>
<li>功能：用作统计使用，又称为聚合函数或统计函数或组函数；（多个输入，一个输出）</li>
<li>分类：sum 求和、avg 平均值、max 最大值、min 最小值、count 计算个数；</li>
</ul>
<h5 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1. 简单使用"></a>1. 简单使用</h5><p><code>select sum(salary) from employees;</code></p>
<h5 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h5><ol>
<li>sum 、avg一般用于处理数值型；max、min、count可以处理任何类型<br></li>
<li>以上分组函数都忽略null值；<br></li>
<li>和distinct搭配使用去重；<br><br> <code>select sum(distinct salary),sum(salary) from employees;</code><br> <code>select count(disinct salary) from employees;</code></li>
<li>count函数；<br><br> <code>select count(salary) from employees;</code> <br><br> <code>select count(*) from employees;</code> (常用来统计行数，更常用) <br><br> <code>select count(1) from employees;</code> (count函数里可以传常量值，表示在表中加一列常量，返回行数) <br><br> 效率： <br><ul>
<li>MYISAM存储引擎下，count(*) 的效率高；<br></li>
<li>INNODB存储引擎下，count(*)和count(1)效率差不多，都比count(字段要高一些);<br></li>
</ul>
</li>
</ol>
<ul>
<li>练习：<br><br>查询员工工资的最大值、最小值，平均值和总和；<br></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	max(salary),</span><br><span class="line">	min(salary),</span><br><span class="line">	avg(salary),</span><br><span class="line">	sum(salary)</span><br><span class="line">from</span><br><span class="line">	employees;</span><br></pre></td></tr></table></figure>
<p>查询员工表中的最大入职时间和最小入职时间的相差天数;<br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	DATEDIFF(max(hiredate),min(hiredate)) diffrence</span><br><span class="line">from</span><br><span class="line">	employees;</span><br></pre></td></tr></table></figure>
<p>查询部门编号为90的员工个数；<br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(*)</span><br><span class="line">from employees</span><br><span class="line">where department_id = 90;</span><br></pre></td></tr></table></figure>
<h3 id="5-分组查询"><a href="#5-分组查询" class="headerlink" title="5. 分组查询"></a>5. 分组查询</h3><ul>
<li>分组查询中的筛选条件分为两类：<br><br>  1.分组前查询；(数据源：原始表；位置：group by的前面 where)<br><br>  2.分组后查询;（数据源：分组后的结果集；位置：group by的后面 having）<br><br>  <strong>分组函数做条件肯定是放在having子句中</strong></li>
<li>group by子句支持单个字段分组，也支持多个字段分组（多个字段之间用逗号隔开没有顺序要求），也支持表达式或函数；<br></li>
<li>也可添加排序（排序放在group by后面）；</li>
<li>引入：查询每个部门的平均工资;<br><blockquote>
<p>可以使用GROUP BY子句将表中的数据分为若干组；</p>
</blockquote>
</li>
<li>语法：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT column(要求出现在group by的后面),group_function(column)</span><br><span class="line">FROM table</span><br><span class="line">[WHERE contion]</span><br><span class="line">[GROUP BY group_by_expression]</span><br><span class="line">[ORDER BY column];</span><br></pre></td></tr></table></figure>
<strong>column（要查询的列表）比较特殊，要求是分组函数(group_function)和group by后出现的字段</strong><br></li>
</ul>
<hr>
<ul>
<li>案例一：查询每个工种的最高工资；<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select job_id,max(salary),</span><br><span class="line">from employees</span><br><span class="line">group by job_id;</span><br></pre></td></tr></table></figure></li>
<li>案例二：查询每个位置上的部门个数；<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select location_id,count(*)</span><br><span class="line">from departments</span><br><span class="line">group by location_id;</span><br></pre></td></tr></table></figure></li>
<li>案例三：查询邮箱中包含a字符的，每个部门的平均工资；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select avg(salary),department_id</span><br><span class="line">from employees</span><br><span class="line">where email like &#x27;%a%&#x27;</span><br><span class="line">group by department_id;</span><br></pre></td></tr></table></figure></li>
<li>案例四：查询每个领导手下有奖金的员工的最高工资；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select max(salary),manager_id</span><br><span class="line">from employees</span><br><span class="line">where commission_pct is not null</span><br><span class="line">group by manager_id;</span><br></pre></td></tr></table></figure></li>
<li>案例五：查询哪个部门的员工个数&gt;2 (添加分组后的筛选；先分组，再筛选。关键字HAVING)<ol>
<li>查询每个部门的员工个数 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(*),department_id</span><br><span class="line">from employees</span><br><span class="line">group by department_id;</span><br></pre></td></tr></table></figure></li>
<li>根据1的结果进行筛选，查询哪个部门的员工个数&gt;2 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select count(*),department_id</span><br><span class="line">from employees</span><br><span class="line">group by department_id</span><br><span class="line">having count(*)&gt;2;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>案例六：查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select job_id,max(salary)</span><br><span class="line">from employees</span><br><span class="line">where commission_pct is not null</span><br><span class="line">group by job_id</span><br><span class="line">having max(salary) &gt; 12000;</span><br></pre></td></tr></table></figure></li>
<li>案例七：查询领导编号&gt;102的每个领导手下的员工最低工资&gt;5000的领导编号，以及其最低工资；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select manager_id,min(salary) 最低工资</span><br><span class="line">from employees</span><br><span class="line">where manager_id&gt;102</span><br><span class="line">group by manager_id</span><br><span class="line">having 最低工资&gt;5000;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>按表达式或函数分组；<br></p>
<ul>
<li>案例1：按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数&gt;5的有哪些  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select length(last_name),count(*)</span><br><span class="line">from employees</span><br><span class="line">group by length(last_name)</span><br><span class="line">having count(*)&gt;5;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>按多个字段分组</p>
<ul>
<li>案例：查询每个部门每个工种的员工的平均工资  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select department_id,job_id,avg(salary)</span><br><span class="line">from employees</span><br><span class="line">group by department_id,job_id;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>添加排序</p>
<ul>
<li>案例：查询每个部门每个工种的员工的平均工资，并且按平均工资的高低显示  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select department_id,job_id,avg(salary)</span><br><span class="line">from employees</span><br><span class="line">group by department_id,job_id</span><br><span class="line">order by avg(salary) desc;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>练习：<br><br>查询各job_id的员工工资的最大值、最小值、平均值、总和，并按job_id升序；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select job_id,max(salary),min(salary),avg(salary),sum(salary)</span><br><span class="line">from employees</span><br><span class="line">group by job_id</span><br><span class="line">order by job_id asc;</span><br></pre></td></tr></table></figure>
<p>查询员工的最高工资和最低工资的差距(DIFFERENCE)；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select max(salary) - min(salary) DIFFERENCE</span><br><span class="line">from employees;</span><br></pre></td></tr></table></figure>
<p>查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select manager_id,min(salary)</span><br><span class="line">from employees</span><br><span class="line">where manager_id is not null</span><br><span class="line">group by manager_id</span><br><span class="line">having min(salary)&gt;=6000;</span><br></pre></td></tr></table></figure>
<p>查询所有部门的编号，员工数量和工资平均值，并按平均工资降序；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select department_id,count(*),avg(salary)</span><br><span class="line">from employees</span><br><span class="line">group by department_id</span><br><span class="line">order by avg(salary) desc;</span><br></pre></td></tr></table></figure>
<p>选择具有各个job_id的员工个数；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select job_id,count(*)</span><br><span class="line">from employees</span><br><span class="line">group by job_id;</span><br></pre></td></tr></table></figure>

<h3 id="6-连接查询-又称多表查询"><a href="#6-连接查询-又称多表查询" class="headerlink" title="6. 连接查询(又称多表查询)"></a>6. 连接查询(又称多表查询)</h3><p>当查询的字段来自于多个表时，就会用到连接查询；<br><br><strong>笛卡尔乘积现象</strong>：表1有m行，表2有n行，结果&#x3D;m×n行；<strong>错误原因</strong>：没有添加有效的连接条件；</p>
<ul>
<li><p>分类<br><br>  1.按年代分类：<br></p>
<ul>
<li>sql92标准；<br></li>
<li>sql99标准;[推荐]；支持内连+外连(左外和右外)+交叉连接 <br></li>
</ul>
<p>  2.按功能分类：<br></p>
<ul>
<li>内连接：<br><br>  1.等值连接；<br>  2.非等值连接；<br>  3.自连接；</li>
<li>外连接:<br><br>  1.左外连接；<br>  2.右外连接；<br>  3.全外连接；</li>
<li>交叉连接;<br></li>
</ul>
</li>
</ul>
<h4 id="一、sql92语法"><a href="#一、sql92语法" class="headerlink" title="一、sql92语法"></a>一、sql92语法</h4><h4 id="1-内连接"><a href="#1-内连接" class="headerlink" title="1. 内连接"></a>1. 内连接</h4><h5 id="1-等值连接"><a href="#1-等值连接" class="headerlink" title="1. 等值连接"></a>1. 等值连接</h5><ul>
<li>案例1：查询女神名和对应的男朋友名<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">selet name,boyname</span><br><span class="line">from boys,beauty</span><br><span class="line">where beauty.boyfriend_id=boys.id;</span><br></pre></td></tr></table></figure></li>
<li>案例2：查询员工名和对应的部门名<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select last_name,department_name</span><br><span class="line">from employees,departments</span><br><span class="line">where employees.`department_id`=departments.`department_id`;</span><br></pre></td></tr></table></figure></li>
<li>案例3：查询员工名、工种号、工种名;<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select last_name,e.`job_id`,job_title</span><br><span class="line">from employees as e,jobs as j</span><br><span class="line">where e.`job_id`=j.`job_id`;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>可以为表起别名；</strong>,提高语句的简洁度，区分多个重名的字段；<strong>如果为表起了别名，则查询的字段就不能使用原来的表名去限定，要用别名，要么就不用</strong>；<br></p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select employees.last_name,employees.`job_id`,jobs.job_title</span><br><span class="line">from employees as e,jobs as j</span><br><span class="line">where e.`job_id`=j.`job_id`;</span><br><span class="line">不可取，会报错</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<hr>
<ol>
<li><strong>可以加筛选</strong></li>
</ol>
<ul>
<li>案例1：查询有奖金的员工名、部门名;<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select last_name,department_name</span><br><span class="line">from employees e,departments d</span><br><span class="line">where e.`department_id`=d.`department_id`</span><br><span class="line">and e.commision_pct is not null;</span><br></pre></td></tr></table></figure></li>
<li>案例2：查询城市中第二个字符为o的部门名和城市名；<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select department_name,city</span><br><span class="line">from departments d,locations l</span><br><span class="line">where d.`location_id`=l.`location_id`</span><br><span class="line">and city like &#x27;_o%&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ol start="2">
<li><strong>可以加分组</strong></li>
</ol>
<ul>
<li>案例1：查询每个城市的部门个数；<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select count(*) 个数,city</span><br><span class="line">from departments d,locations l</span><br><span class="line">where d.`location_id`=l.`location_id`</span><br><span class="line">group by city;</span><br></pre></td></tr></table></figure></li>
<li>案例2：查询有奖金的每个部门的部门名、部门的领导标号和该部门的最低工资；<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select department_name,d.manager_id ,min(salary)</span><br><span class="line">from employees e,departments d</span><br><span class="line">where e.`department_id`=d.`department_id`</span><br><span class="line">and commision_pct is not null</span><br><span class="line">group by e.department_name,d.manager_id;</span><br><span class="line">group by后面跟两列是保证两列行数相同；</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ol start="3">
<li><strong>可以加排序</strong></li>
</ol>
<ul>
<li>案例：查询每个工种的工种名和员工的个数，并且按员工个数降序；<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select count(*),j.job_title</span><br><span class="line">from employees e,jobs j</span><br><span class="line">where e.`job_id`=j.`job_id`</span><br><span class="line">group by j.job_title</span><br><span class="line">order by count(*) desc;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ol start="4">
<li><strong>可以实现三表连接</strong></li>
</ol>
<ul>
<li>案例：查询员工名、部门名和所在的城市；<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select last_name,department_name,city</span><br><span class="line">from employees e, departments d, locations l</span><br><span class="line">where e.`department_id`=d.`department_id`</span><br><span class="line">and d.`location_id`=l.`location_id`;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ol start="5">
<li><strong>等值连接总结</strong><ol>
<li>多表连接的结果为多表的交集部分；<br></li>
<li>n表连接，至少需要n-1个连接条件；<br></li>
<li>多表的顺序没有要求；<br></li>
<li>一般需要为表起别名；<br></li>
<li>可以搭配前面介绍的所有子句；<br></li>
</ol>
</li>
</ol>
<h5 id="2-非等值连接"><a href="#2-非等值连接" class="headerlink" title="2. 非等值连接"></a>2. 非等值连接</h5><p>连接条件中不用等于号;<br></p>
<ul>
<li>案例1：查询员工的工资和工资级别；<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select salary,grade_level</span><br><span class="line">from employees e,job_grades g</span><br><span class="line">where salary between g.`lowest_sal` and g.`highest_sal`;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-自连接"><a href="#3-自连接" class="headerlink" title="3. 自连接"></a>3. 自连接</h5><ul>
<li>案例：查询员工名和上级的名称；<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select e.employee_id,e.last_name,m.employee_id,m.last_name</span><br><span class="line">from employees e, employees m</span><br><span class="line">where e.`manager_id`=m.`employee_id`;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>练习：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select max(salary),avg(salary)</span><br><span class="line">from employees;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select employee_id,job_id,last_name</span><br><span class="line">from employees</span><br><span class="line">order by department_id desc,salary asc;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select job_id,last_name</span><br><span class="line">from employees</span><br><span class="line">where job_id like &#x27;%a%e%&#x27;;</span><br></pre></td></tr></table></figure>
<p>显示所有员工的姓名，部门号和部门名称；<br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select last_name,d.department_id,department_name</span><br><span class="line">from employees e,departments d</span><br><span class="line">where e.&#x27;department_id&#x27;=d.`department_id`;</span><br></pre></td></tr></table></figure>
<p>查询90号部门员工的job_id和90号部门的location_id;<br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select job_id,location_id</span><br><span class="line">from employees e,departments d</span><br><span class="line">where e.`department_id`= d.`department_id`</span><br><span class="line">and e.`department_id`=90;</span><br></pre></td></tr></table></figure>
<p>选择所有有奖金的员工的last_name,department_name,location_id,city;<br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select last_name,department_name,location_id,city</span><br><span class="line">from employees e,departments d,locations l</span><br><span class="line">where e.`department_id`=d.`department_id`</span><br><span class="line">and d.`location_id`=l.`location_id`</span><br><span class="line">and e.`commission_pct` is not null;</span><br></pre></td></tr></table></figure>
<p>选择city在Toronto工作的员工的last_name,job_id,department_id,department_name;<br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select last_name,job_id,department_id,department_name</span><br><span class="line">from employees e,departments d,locations l</span><br><span class="line">where e.`department_id`=d.`department_id`</span><br><span class="line">and d.`location_id`=l.`location_id`</span><br><span class="line">and city=&#x27;Toronto&#x27;;</span><br></pre></td></tr></table></figure>
<p>查询每个工种、每个部门的部门名、工种名和最低工资；<br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select deparment_name,job_title,min(salary)</span><br><span class="line">from employees e,departments d,jobs j</span><br><span class="line">where e.`department_id`=d.`department_id`</span><br><span class="line">and e.`job_id`=j.`job_id`</span><br><span class="line">group by j.job_title,d.department_id;</span><br></pre></td></tr></table></figure>
<p>查询每个国家下的部门个数大于2的国家编号；<br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select country_id,count(*)</span><br><span class="line">from departments d,locations l</span><br><span class="line">where d.`location_id`=l.`location_id`</span><br><span class="line">group by country_id</span><br><span class="line">having count(*)&gt;2;</span><br></pre></td></tr></table></figure>
<h4 id="二、sql99语法；"><a href="#二、sql99语法；" class="headerlink" title="二、sql99语法；"></a>二、sql99语法；</h4><ul>
<li>语法：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表1 别名 【连接类型】</span><br><span class="line">join 表2 别名</span><br><span class="line">on 连接条件</span><br><span class="line">【where 筛选条件】</span><br><span class="line">【group by 分组】</span><br><span class="line">【having 筛选条件】</span><br><span class="line">【order by 排序列表】</span><br></pre></td></tr></table></figure></li>
<li>分类<ol>
<li>内连接：inner <br><ul>
<li>等值连接；<br></li>
<li>非等值连接；<br></li>
<li>自连接；<br></li>
</ul>
</li>
<li>外连接：<ul>
<li>左外：left [outer] <br></li>
<li>右外：right [outer] <br></li>
<li>全外： full [outer] <br></li>
</ul>
</li>
<li>交叉连接：cross <br></li>
</ol>
</li>
</ul>
<h5 id="1-内连接："><a href="#1-内连接：" class="headerlink" title="1. 内连接："></a>1. 内连接：</h5><ul>
<li>语法：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表1 别名</span><br><span class="line">inner join 表2 别名</span><br><span class="line">on 连接条件;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="1-等值连接-1"><a href="#1-等值连接-1" class="headerlink" title="1. 等值连接"></a>1. 等值连接</h6><blockquote>
<p>sql99的等值连接特点：<br><br>1.可以添加排序、分组和筛选；<br><br>2.inner可以省略；<br><br>3.筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读;<br><br>4.inner join和sql92语法中的等值连接效果是一样的，<strong>都是查询多表的交集部分</strong>；<br></p>
</blockquote>
<ul>
<li>案例1：查询员工名、部门名；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select last_name,department_name</span><br><span class="line">from employees e</span><br><span class="line">inner join departments d</span><br><span class="line">on e.`department_id`=d.`department_id`;</span><br></pre></td></tr></table></figure></li>
<li>案例2：查询名字中包含e的员工名和工种名(筛选)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select last_name,job_title</span><br><span class="line">from employees e</span><br><span class="line">inner join jobs j</span><br><span class="line">on e.`job_id`=j.`job_id`</span><br><span class="line">where e.`last_name` like &#x27;%e%&#x27;;</span><br></pre></td></tr></table></figure></li>
<li>案例3：查询部门个数&gt;3的城市名和部门个数；(分组+筛选)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select l.city,count(*)</span><br><span class="line">from locations l</span><br><span class="line">inner join departments d</span><br><span class="line">on l.`location_id`=d.`location_id`</span><br><span class="line">group by l.city</span><br><span class="line">having count(*)&gt;3;</span><br></pre></td></tr></table></figure></li>
<li>案例4：查询哪个部门的部门员工个数&gt;3的部门名和员工个数，并按个数降序排列；(排序)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select department_name,count(*)</span><br><span class="line">from departments d</span><br><span class="line">inner join employees e</span><br><span class="line">on d.`department_id`=e.`department_id`</span><br><span class="line">group by department_name</span><br><span class="line">having count(*)&gt;3</span><br><span class="line">order by count(*) desc;</span><br></pre></td></tr></table></figure></li>
<li>案例5：查询员工名、部门名、工种名，并按部门名降序(三表连接)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select last_name,department_name,job_title</span><br><span class="line">from employees e</span><br><span class="line">inner join departments d</span><br><span class="line">on e.`department_id`=d.`department_id`</span><br><span class="line">inner join jobs j</span><br><span class="line">on e.`job_id`=j.`job_id`</span><br><span class="line">order by d.department_name desc;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="2-非等值连接-1"><a href="#2-非等值连接-1" class="headerlink" title="2. 非等值连接"></a>2. 非等值连接</h6><ul>
<li>案例：查询员工的工资级别；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select salary,grade_level</span><br><span class="line">from employee e</span><br><span class="line">join job_grade g</span><br><span class="line">on e.`salary` between g.`lowest_sal` and g.`highest_sal`;</span><br></pre></td></tr></table></figure></li>
<li>案例：查询工资级别的个数&gt;2的个数，并且按工资级别降序；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select count(*),grade_level</span><br><span class="line">from employees e</span><br><span class="line">join job_grade g</span><br><span class="line">where e.`salary` between g.`lowest_sal` and g.`highest_sal`</span><br><span class="line">group by grade_level</span><br><span class="line">having count(*)&gt;20</span><br><span class="line">order by grade_level desc;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="3-自连接-1"><a href="#3-自连接-1" class="headerlink" title="3. 自连接"></a>3. 自连接</h6><ul>
<li>案例：查询员工名和对应的经理名；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select e.`last_name`,m.`last_name`</span><br><span class="line">from employees e</span><br><span class="line">join employees m</span><br><span class="line">where e.`manager_id`=m.`employee_id`;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-外连接："><a href="#2-外连接：" class="headerlink" title="2. 外连接："></a>2. 外连接：</h5><blockquote>
<p>应用场景：用于查询一个表中有，另一个表中没有的记录；<br><br>特点：<br><br>1. 外连接的查询结果为主表中的所有记录，<br><br>	如果从表中有和它匹配的，则显示匹配的值；<br><br>	如果从表中没有和它匹配的，则显示null；<br><br>	外连接查询的结果 &#x3D; 内连接查询结果 + 主表中有而从表中没有的记录；<br><br>2. 左外连接，left join左边的是主表；<br><br>	右外连接，right join右边的是主表；<br><br>3. 左外和右外，交换两个表的顺序，可以实现同样的效果；<br><br>4. 全外连接 &#x3D; 内连接的结果 + 表1中有但表2没有的 + 表2中有但表1中没有的；<br></p>
</blockquote>
<ul>
<li>引入:查询男朋友名字不在男神表中的女神名；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select b.name</span><br><span class="line">from beauty b</span><br><span class="line">left outer join boys bo</span><br><span class="line">on b.`boyfriend_id`=bo.`id`</span><br><span class="line">where bo.`id` is null;</span><br></pre></td></tr></table></figure></li>
<li>案例1：查询哪个部门没有员工；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select d.`department_name`</span><br><span class="line">from departments d</span><br><span class="line">left outer join employees e</span><br><span class="line">on d.`department_id`=e.`department_id`</span><br><span class="line">where e.`employee.id` is null;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-交叉连接"><a href="#3-交叉连接" class="headerlink" title="3. 交叉连接"></a>3. 交叉连接</h5><blockquote>
<p>其实就是笛卡尔乘积；</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select b.*,bo.*</span><br><span class="line">from beauty b,</span><br><span class="line">cross join boys bo;</span><br></pre></td></tr></table></figure>
<h5 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h5><ol>
<li>内连接：求交集；<br></li>
<li>外连接：分主表和从表，查询主表的所有记录；（查询交集和主表特有的部分）<br><br>（可以画图理解，交集并集图）</li>
</ol>
<hr>
<p>练习：<br><br>查询编号&gt;3的女神的男朋友信息，如果有则列出详细，如果没有，用null填充；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select b.`name`,bo.*</span><br><span class="line">from beauty b</span><br><span class="line">left outer join boys bo</span><br><span class="line">on b.`boyfriend_id`=bo.`id`</span><br><span class="line">where b.`id`&gt;3;</span><br></pre></td></tr></table></figure>
<p>查询哪个城市没有部门</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select city</span><br><span class="line">from locations l</span><br><span class="line">left outer departments d</span><br><span class="line">on l.`location_id`=d.`location_id`</span><br><span class="line">where d.`department_id` is null;</span><br></pre></td></tr></table></figure>
<p>查询部门名为SAL或IT的员工信息；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select e.*</span><br><span class="line">from employees e</span><br><span class="line">right outer join departments d</span><br><span class="line">on e.`department_id`=d.`department_id`</span><br><span class="line">where d.`department_name` in(&#x27;SAL&#x27;,&#x27;IT&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="7-子查询"><a href="#7-子查询" class="headerlink" title="7. 子查询"></a>7. 子查询</h3><blockquote>
<p>含义：出现在其他语句内部的select语句，称为子查询或内查询；内部嵌套其他select语句的查询，成为外查询或主查询；<br><br>分类：<br><br>1.按子查询出现的位置：<br><br>select后面（只支持标量子查询）；<br><br>from后面；（支持表子查询）<br><br>where或having后面；（支持标量子查询，列子查询，行子查询） 【重点】<br><br>exists后面（相关子查询）（表子查询）;<br><br>2.按结果集的行列数不同：<br><br>标量子查询（结果集只有一行一列）；<br><br>列子查询（结果集有一列多行）；<br><br>行子查询（结果集有一行多列）；<br><br>表子查询（结果集一般为多行多列）；<br></p>
</blockquote>
<h4 id="1-where或having后面"><a href="#1-where或having后面" class="headerlink" title="1. where或having后面"></a>1. where或having后面</h4><blockquote>
<p>特点：<br><br>子查询一般放在小括号内；<br><br>子查询一般放在条件的右侧；<br><br>标量子查询，一般搭配着单行操作符使用；(&gt; &lt; &#x3D; &lt;&gt; &gt;&#x3D; &lt;&#x3D; )<br><br>列子查询，一般搭配着多行操作符使用；(in&#x2F;not in,any&#x2F;some,all);<br><br>子查询的执行优先于主查询；<br></p>
</blockquote>
<h5 id="1-标量子查询（单行子查询）"><a href="#1-标量子查询（单行子查询）" class="headerlink" title="1. 标量子查询（单行子查询）"></a>1. 标量子查询（单行子查询）</h5><ul>
<li>案例1：谁的工资比Abel高？  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from employees</span><br><span class="line">where salary&gt;(</span><br><span class="line">	select salary</span><br><span class="line">	from employees</span><br><span class="line">	where last_name=&#x27;Abel&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>案例2：返回job_id与141号员工相同，salary比143号员工多的员工的姓名，job_id和工资  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select last_name,job_id,salary</span><br><span class="line">from employees</span><br><span class="line">where job_id=(</span><br><span class="line">	select job_id</span><br><span class="line">	from employees</span><br><span class="line">	where employee_id=141</span><br><span class="line">)and salary&gt;(</span><br><span class="line">	select salary</span><br><span class="line">	from employees</span><br><span class="line">	where employee_id=143</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>案例3：返回公司工资最少的员工的last_name,job_id和salary  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select last_name,job_id,salary</span><br><span class="line">from employees</span><br><span class="line">where salary=(</span><br><span class="line">	select min(salary)</span><br><span class="line">	from employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>案例4：查询最低工资大于50部门最低工资的部门id和其最低工资  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select department_id,min(salary)</span><br><span class="line">from employees</span><br><span class="line">group by department_id</span><br><span class="line">having min(salary)&gt;(</span><br><span class="line">	select min(salary)</span><br><span class="line">	from employees</span><br><span class="line">	where department_id=50</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-列子查询（多行子查询）"><a href="#2-列子查询（多行子查询）" class="headerlink" title="2. 列子查询（多行子查询）"></a>2. 列子查询（多行子查询）</h5><ul>
<li>案例1：返回location_id是1400或1700的部门中的所有员工姓名  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   select last_name</span><br><span class="line">from employees</span><br><span class="line">where department_id in(</span><br><span class="line">	select distinct department_id</span><br><span class="line">	from departments</span><br><span class="line">	where location_id in (1400,1700)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>案例2：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id以及salary;  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select employee_id,last_name,job_id,salary</span><br><span class="line">from employees</span><br><span class="line">where salary&lt;any(</span><br><span class="line">	select distinct salary</span><br><span class="line">	from employees</span><br><span class="line">	where job_id=&#x27;IT_PROG&#x27;</span><br><span class="line">) and job_id&lt;&gt;&#x27;IT_PROG&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-行子查询（多列多行）"><a href="#3-行子查询（多列多行）" class="headerlink" title="3. 行子查询（多列多行）"></a>3. 行子查询（多列多行）</h5><ul>
<li>案例1：查询员工编号最小并且工资最高的员工信息;<br><br>  以前的做法：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from employees</span><br><span class="line">where employee_id=(</span><br><span class="line">	select min(employee_id)</span><br><span class="line">	from employees</span><br><span class="line">) and salary=(</span><br><span class="line">	select max(salary)</span><br><span class="line">	from employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
  行子查询方法：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from employees</span><br><span class="line">where (employee_id,salary)=(</span><br><span class="line">	select min(employee_id),max(salary)</span><br><span class="line">	from employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-select后面"><a href="#2-select后面" class="headerlink" title="2. select后面"></a>2. select后面</h4><ul>
<li>案例:查询每个部门的员工个数  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select d.*,(</span><br><span class="line">	select count(*)</span><br><span class="line">	from employee e</span><br><span class="line">	where e.department_id = d.department_id</span><br><span class="line">) 个数</span><br><span class="line">from departments d;</span><br></pre></td></tr></table></figure></li>
<li>案例2：查询员工号&#x3D;120的部门名；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select (</span><br><span class="line">	select department_name</span><br><span class="line">	from departments d</span><br><span class="line">	inner join employees e</span><br><span class="line">	on d.department_id=e.department_id</span><br><span class="line">	where e.employee_id=102</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-from后面"><a href="#3-from后面" class="headerlink" title="3. from后面"></a>3. from后面</h4><blockquote>
<p>将子查询结果充当一张表，要求必须起别名；</p>
</blockquote>
<ul>
<li>案例：查询每个部门的平均工资的工资等级  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select ag_dep.ag,g.grade_level</span><br><span class="line">from(</span><br><span class="line">	select avg(salary) ag,department_id</span><br><span class="line">	from employees</span><br><span class="line">	group by department_id</span><br><span class="line">) ag_dep</span><br><span class="line">inner join job_grades g</span><br><span class="line">on ag_dep.ag between lowest_sal and highest_sal;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-exists后面（相关子查询）"><a href="#4-exists后面（相关子查询）" class="headerlink" title="4. exists后面（相关子查询）"></a>4. exists后面（相关子查询）</h4><blockquote>
<p>exists（完整的查询语句）,结果是布尔值；</p>
</blockquote>
<ul>
<li>案例1：查询有员工的部门名  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select department_name</span><br><span class="line">from departments d</span><br><span class="line">where exists(</span><br><span class="line">	select *</span><br><span class="line">	from employees e</span><br><span class="line">	where e.`department_id`=d.`department_id`</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#用in也可以做</span><br><span class="line">select department_name</span><br><span class="line">from departments d</span><br><span class="line">where d.`department_id` in(</span><br><span class="line">	select department_id</span><br><span class="line">	from employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>案例2：查询没有女朋友的男神信息；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select boys.*</span><br><span class="line">from boys</span><br><span class="line">where boys.id not in(</span><br><span class="line">	select boyfriend_id</span><br><span class="line">	from beauty</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select boys.*</span><br><span class="line">from boys</span><br><span class="line">where  not exists(</span><br><span class="line">	select *</span><br><span class="line">	frmo beauty</span><br><span class="line">	where beauty.boyfriend_id=boys.id</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>练习：<br></p>
<ol>
<li>查询和Zlotkey相同部门的员工姓名和工资； <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select last_name,salary</span><br><span class="line">from employees</span><br><span class="line">where department_id=(</span><br><span class="line">	select department_id</span><br><span class="line">	from employees</span><br><span class="line">	where last_name=&#x27;Zlotkey&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>查询工资比公司平均工资高的员工的员工号，姓名和工资； <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select employee_id,last_name,salary</span><br><span class="line">from employees</span><br><span class="line">where salary &gt; (</span><br><span class="line">	select avg(salary)</span><br><span class="line">	from employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>查询各部门中工资比本部门平均工资高的员工的员工号，姓名和工资； <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select employee_id,last_name,salary,department_id</span><br><span class="line">from (</span><br><span class="line">	select avg(salary) avg,department_id</span><br><span class="line">	from employees</span><br><span class="line">	group by department_id</span><br><span class="line">) avg_dep</span><br><span class="line">inner join employees e</span><br><span class="line">on avg_dep.`department_id`=e.`department_id`</span><br><span class="line">where e.salary &gt; avg_dep.avg;</span><br></pre></td></tr></table></figure></li>
<li>查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select employee_id,last_name</span><br><span class="line">from employees e</span><br><span class="line">where e.department_id in(</span><br><span class="line">	select distinct department_id</span><br><span class="line">	from employees</span><br><span class="line">	where last_name = &#x27;%u%&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>查询在部门的location_id为1700的部门工作的员工的员工号； <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select employee_id</span><br><span class="line">from employees</span><br><span class="line">where department_id in(</span><br><span class="line">	select distinct department_id</span><br><span class="line">	from departments</span><br><span class="line">	where location_id=1700</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>查询管理者是King的员工姓名和工资； <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select last_name,salary</span><br><span class="line">from employees</span><br><span class="line">where manager_id=(</span><br><span class="line">	select employee_id</span><br><span class="line">	from employees</span><br><span class="line">	where last_name = &#x27;King&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>查询工资最高的员工的姓名，要求first_name和last_name显示为一列，列名为姓名； <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select concat(first_name,last_name) 姓名</span><br><span class="line">from employees</span><br><span class="line">where salary=(</span><br><span class="line">	select max(salary)</span><br><span class="line">	from employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p>子查询经典案例：<br></p>
<ol>
<li>查询工资最低的员工信息：last_name,salary <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select last_name,salary</span><br><span class="line">from employees</span><br><span class="line">where salary = (</span><br><span class="line">	select min(salary)</span><br><span class="line">	from employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>查询平均工资最低的部门信息； <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select department_id,department_name</span><br><span class="line">from(</span><br><span class="line">	select avg(salary),department_id</span><br><span class="line">	from employees</span><br><span class="line">	group by department_id</span><br><span class="line">	order by avg(salary) asc</span><br><span class="line">	limit 1</span><br><span class="line">) avg_dep</span><br><span class="line">inner join departments d</span><br><span class="line">on d.`department_id`=avg_dep.`department_id;`</span><br></pre></td></tr></table></figure></li>
<li>查询平均工资最低的部门信息和该部门的平均工资； <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select d.*,avg_dep.avg(salary)</span><br><span class="line">from(</span><br><span class="line">	#平均工资最低的部门id</span><br><span class="line">	select avg(salary),department_id</span><br><span class="line">	from employees</span><br><span class="line">	group by department_id</span><br><span class="line">	order by avg(salary) asc</span><br><span class="line">	limit 1</span><br><span class="line">) avg_dep</span><br><span class="line">inner join departments d</span><br><span class="line">on d.`department_id`=avg_dep.`department_id;`</span><br></pre></td></tr></table></figure></li>
<li>查询平均工资最高的job信息； <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from jobs</span><br><span class="line">where job_id =(</span><br><span class="line">	# 查询平均工资最高的job_id</span><br><span class="line">	select avg(salary),job_id</span><br><span class="line">	from employees </span><br><span class="line">	group by job_id</span><br><span class="line">	order by avg(salary) desc</span><br><span class="line">	limit 1</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>查询平均工资高于公司平均工资的部门有哪些； <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select department_id,avg(salary) 部门平均工资</span><br><span class="line">from employees e</span><br><span class="line">group by department_id</span><br><span class="line">having 部门平均工资&gt;(</span><br><span class="line">	select avg(salary) 公司平均工资</span><br><span class="line">	from employees</span><br><span class="line">)；</span><br></pre></td></tr></table></figure></li>
<li>查询出公司中所有manager的详细信息； <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from employees </span><br><span class="line">where employees_id=any(</span><br><span class="line">	select distinct manager_id</span><br><span class="line">	from employees</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>各个部门中最高工资最低的那个部门的最低工资是多少；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select min(salary),department_id</span><br><span class="line">from employees</span><br><span class="line">where department_id = (</span><br><span class="line">	# 最高工资最低的部门id</span><br><span class="line">	select department_id</span><br><span class="line">	from employees e</span><br><span class="line">	group by department_id; </span><br><span class="line">	order by max(salary) </span><br><span class="line">	limit 1</span><br><span class="line">) </span><br></pre></td></tr></table></figure></li>
<li>查询平均工资最高的部门的manager的详细信息：last_name,department_id,email,salary; <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select last_name,e.department_id,email,salary</span><br><span class="line">from employees e</span><br><span class="line">inner join departments d </span><br><span class="line">on e.department_id=d.department_id</span><br><span class="line">where d.department_id = (</span><br><span class="line">	#平均工资最高的部门id</span><br><span class="line">	select department_id,</span><br><span class="line">	from employees</span><br><span class="line">	group by department_id</span><br><span class="line">	order by avg(salary) desc</span><br><span class="line">	limit 1</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="8-分页查询"><a href="#8-分页查询" class="headerlink" title="8. 分页查询"></a>8. 分页查询</h3><blockquote>
<p>当要显示的数据一页显示不全，需要分页提交sql请求;<br><br>特点：<br><br>limit 子句要放在sql语句的最后。也是最后执行limit； <br><br>公式：要显示的页数page，每页的条目数size    <br><br>select .. from .. limit (page-1)*size,size;</p>
</blockquote>
<ul>
<li>语法：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表</span><br><span class="line">【join type join 表2</span><br><span class="line">on 连接条件</span><br><span class="line">where 筛选条件</span><br><span class="line">group by 分组字段</span><br><span class="line">having 分组后的筛选</span><br><span class="line">order by排序后的字段】</span><br><span class="line">limit 【offset,】size；</span><br></pre></td></tr></table></figure>
  offset要显示条目的起始索引（<strong>起始索引和instr，substr不同，从0开始</strong>）,size 要现实的条目个数</li>
<li>案例1：查询前五条员工信息；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from employees</span><br><span class="line">limit 0,5;</span><br></pre></td></tr></table></figure>
  <strong>offset如果是0，可以省略不写</strong></li>
<li>案例2：查询第11条到第25条；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees limit 10,25;</span><br></pre></td></tr></table></figure></li>
<li>案例3：有奖金的员工信息，并且工资较高的前10名显示出来；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from employees</span><br><span class="line">where commission_pct is not null</span><br><span class="line">order by salary desc</span><br><span class="line">limit 10;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-union联合查询"><a href="#9-union联合查询" class="headerlink" title="9. union联合查询"></a>9. union联合查询</h3><blockquote>
<p>将多条查询语句的结果合并成一个结果<br><br>应用场景：<br><br>要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时；<br><br>特点：<br><br>要求多条查询语句的查询列数一致；<br><br>要求多条查询语句查询的每一列的类型和顺序最好一致；<br><br>union关键字默认去重，如果使用 union all ，则不去重；<br></p>
</blockquote>
<ul>
<li>语法：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查询语句1</span><br><span class="line">union</span><br><span class="line">查询语句2</span><br><span class="line">union</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>引入案例：查询部门编号&gt;90或邮箱包含a的员工信息  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from employees where email like &#x27;%a%&#x27;</span><br><span class="line">union</span><br><span class="line">select * from employees where department_id&gt;90;</span><br></pre></td></tr></table></figure></li>
<li>案例： 查询中国用户中男性的信息以及外国用户中男性的信息；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id, cname, cname,csex from t_ca where csex=&#x27;男&#x27;</span><br><span class="line">union</span><br><span class="line">select t_id,tName,tGender from t_ua where tGender=&#x27;mail&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二、DML"><a href="#二、DML" class="headerlink" title="二、DML"></a>二、DML</h2><blockquote>
<p>data manipulation 数据操作语言;<br><br>插入：insert	<br><br>修改：update	<br><br>删除：delete	<br></p>
</blockquote>
<h3 id="1-插入语句"><a href="#1-插入语句" class="headerlink" title="1. 插入语句"></a>1. 插入语句</h3><ul>
<li>语法一：<br>  <code>insert into 表名（列名，...） values（值1，...）</code></li>
<li>注意：<ol>
<li>插入值的类型要与列的类型一致或兼容；<br></li>
<li>不可以为null的值必须插入值，可以为null的列要么插入null，要么直接不写；<br></li>
<li>列的顺序可以调换；<br></li>
<li>插入的时候列数和值数必须一致；<br></li>
<li>可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致<br></li>
</ol>
</li>
<li>语法二：<br>  <code>insert into 表名 set 列名=值，列名=值...</code></li>
<li>两种语法比较：<br></li>
</ul>
<ol>
<li>方式一支持插入多行，方式二不支持； <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into beauty </span><br><span class="line">values(......,....,....),</span><br><span class="line">values(....,.....,...);</span><br></pre></td></tr></table></figure></li>
<li>方式一支持子查询，方式二不支持； <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into beauty(id,name,phone)</span><br><span class="line">select 26,&#x27;宋茜&#x27;,&#x27;11023&#x27;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-删"><a href="#2-删" class="headerlink" title="2. 删"></a>2. 删</h3><ol>
<li>方式1：delete</li>
</ol>
<ul>
<li>语法：<ol>
<li>单表的删除；<br><br>  <code>delete from 表名 where 筛选条件</code>(删除整行)<br>- 案例1：删除手机号以9结尾的女神信息；<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from beauty where phone like &#x27;%9&#x27;;</span><br></pre></td></tr></table></figure></li>
<li>多表的删除；<br><ul>
<li>sql92语法：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete 表1，表2</span><br><span class="line">from 表1 别名，表2 别名</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件;</span><br></pre></td></tr></table></figure></li>
<li>sql99语法：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete 表1，表2</span><br><span class="line">from 表1 别名</span><br><span class="line">inner |left |right join 表2 别名 on 连接条件</span><br><span class="line">where 筛选条件;</span><br></pre></td></tr></table></figure></li>
<li>案例：删除张无忌的女朋友的信息;  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete b</span><br><span class="line">from boys bo</span><br><span class="line">inner join beauty b on b.`boyfriend_id`=bo.`id`</span><br><span class="line">where bo.`boyName`=&#x27;张无忌&#x27;;</span><br></pre></td></tr></table></figure></li>
<li>案例：删除黄晓明的信息以及他女朋友的信息  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete b,bo</span><br><span class="line">from boys bo</span><br><span class="line">inner join beauty b on b.`boyfriend_id`=bo.`id`</span><br><span class="line">where bo.`boyName`=&#x27;黄晓明&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ul>
<ol start="2">
<li>方式2：truncate</li>
</ol>
<ul>
<li>语法：<br>  <code>truncate table 表名</code>(整表删除，不能加where筛选条件)<br>也就是整表清空；<br></li>
</ul>
<ol start="3">
<li><strong>delete和truncate比较；</strong><br><ol>
<li>delete可以加where条件，truncate不能；<br></li>
<li>truncate删除效率较高；<br></li>
<li>加入要删除的表中有自增长列，如果用delete删除后再插入数据，自增长列的值从断电开始；<br> 而truncate删除后，再插入数据，自增长列从1开始；<br></li>
<li>truncate删除没有返回值，delete删除有返回值；<br></li>
<li>truncate删除不能回滚，delete删除可以回滚；<br></li>
</ol>
</li>
</ol>
<h3 id="3-改"><a href="#3-改" class="headerlink" title="3. 改"></a>3. 改</h3><ul>
<li>语法：<br></li>
</ul>
<ol>
<li>修改单表的记录： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update 表名</span><br><span class="line">set 列=新值，列=新值，...</span><br><span class="line">where 筛选条件；</span><br></pre></td></tr></table></figure>
<ul>
<li>案例1：修改beauty中姓唐的人的电话为1883  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	update beauty set phone = &#x27;1883&#x27;</span><br><span class="line">	where name like &#x27;唐%&#x27;;</span><br><span class="line">- 案例2：修改boys中id号为2的名称为张飞，魅力值为10；</span><br><span class="line">	```mysql</span><br><span class="line">	update boys set boyname=&#x27;张飞&#x27;,usercp=10</span><br><span class="line">	where id=2;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>修改多表的记录:<br><ul>
<li>sql92语法：</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">update 表1 别名，表2 别名</span><br><span class="line">set 列=值，...</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件；</span><br></pre></td></tr></table></figure>

<ul>
<li>sql99 语法：</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">update 表1 别名</span><br><span class="line">inner|left|right join 表2 别名</span><br><span class="line">on 连接条件</span><br><span class="line">set 列=值,...</span><br><span class="line">where 筛选条件;</span><br></pre></td></tr></table></figure>

<ul>
<li>案例1：修改张无忌女朋友的手机号为114</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">update boys bo</span><br><span class="line">inner join beauty b</span><br><span class="line">on bo.`id`=b.`boyfriend_id`</span><br><span class="line">set b.`phone`=&#x27;114&#x27;</span><br><span class="line">where bo.&#x27;boyName&#x27;=&#x27;张无忌&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>案例2：修改没有男朋友的女神的男朋友编号都为2号；</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">update boys bo </span><br><span class="line">right join beauty b </span><br><span class="line">on bo.`id`=b.`boyfriend_id`</span><br><span class="line">set b.`boyfriend_id`=2</span><br><span class="line">where bo.`id` is null;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="三、DDL"><a href="#三、DDL" class="headerlink" title="三、DDL"></a>三、DDL</h2><blockquote>
<p>data define language 数据定义语言，库和表的管理；</p>
</blockquote>
<ul>
<li>创建：create</li>
<li>修改：alter</li>
<li>删除：drop</li>
</ul>
<h3 id="1-库的管理"><a href="#1-库的管理" class="headerlink" title="1. 库的管理"></a>1. 库的管理</h3><blockquote>
<p>创建、修改、删除</p>
</blockquote>
<h4 id="1-库的创建；"><a href="#1-库的创建；" class="headerlink" title="1.库的创建；"></a>1.库的创建；</h4><ul>
<li>语法：<br>  <code>create database 库名;</code><br>  <code>create database if not exists 库名;</code></li>
</ul>
<h4 id="2-库的修改"><a href="#2-库的修改" class="headerlink" title="2.库的修改"></a>2.库的修改</h4><ol>
<li>更改库的字符集：<br> <code>alter database books character set gbk;</code></li>
</ol>
<h4 id="3-库的删除"><a href="#3-库的删除" class="headerlink" title="3.库的删除"></a>3.库的删除</h4><pre><code>`drop database if exists books;`
</code></pre>
<h3 id="2-表的管理"><a href="#2-表的管理" class="headerlink" title="2. 表的管理"></a>2. 表的管理</h3><blockquote>
<p>创建、修改、删除</p>
</blockquote>
<h4 id="1-表的创建："><a href="#1-表的创建：" class="headerlink" title="1.表的创建："></a>1.表的创建：</h4><ul>
<li>语法：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">		列名 列的类型【（长度） 约束】</span><br><span class="line">		列名 列的类型【（长度） 约束】</span><br><span class="line">		...</span><br><span class="line">		列名 列的类型【（长度） 约束】</span><br><span class="line">)	</span><br></pre></td></tr></table></figure></li>
<li>案例：创建表Book  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table Book(</span><br><span class="line">	id int,</span><br><span class="line">	bName varchar(20),</span><br><span class="line">	price double,</span><br><span class="line">	author varchar(20),</span><br><span class="line">	publishDate datetime</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-表的修改："><a href="#2-表的修改：" class="headerlink" title="2.表的修改："></a>2.表的修改：</h4><ul>
<li>语法：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名</span><br><span class="line">add|drop|modify|change column 列名 【列类型 约束】;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>修改列名 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># column 可以省略</span><br><span class="line">alter table book change column publishdate pubDate DATETIME;</span><br></pre></td></tr></table></figure></li>
<li>修改列的类型或约束<br> <code>alter table book modify column pubDate TIMESTAMP;</code></li>
<li>添加新列<br> <code>alter table author add column annual double;</code></li>
<li>删除列<br> <code>alter table author drop column annual;</code></li>
<li>修改表名<br> <code>alter table author rename to book_author</code></li>
</ol>
<h4 id="3-表的删除："><a href="#3-表的删除：" class="headerlink" title="3.表的删除："></a>3.表的删除：</h4><pre><code>`drop table if exists author;`
</code></pre>
<p>通用写法：<br><br>	<code>drop database if exists 旧库名;</code><br>	<code>create database 新库名;</code><br>	<code>drop table if exists 旧表名;</code><br>	<code>create table 表名();</code></p>
<h4 id="3-表的复制："><a href="#3-表的复制：" class="headerlink" title="3.表的复制："></a>3.表的复制：</h4><ol>
<li>仅仅复制表的结构：<br> <code>create table copy like author;</code></li>
<li>复制表的结构外加数据 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table copy2 </span><br><span class="line">select * from author</span><br></pre></td></tr></table></figure></li>
<li>只复制部分数据 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table copy3</span><br><span class="line">select id,au_name</span><br><span class="line">from author </span><br><span class="line">where nation=&#x27;中国&#x27;;</span><br></pre></td></tr></table></figure></li>
<li>仅复制某些列，不带数据 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table copy4</span><br><span class="line">select id,au_name</span><br><span class="line">from author</span><br><span class="line">where 0;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-常见约束"><a href="#3-常见约束" class="headerlink" title="3.常见约束"></a>3.常见约束</h3><blockquote>
<p>一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性</p>
</blockquote>
<ul>
<li><p>分类：六大约束</p>
<ol>
<li>NOT NULL:非空，用于保证该字段的值非空；比如姓名，学号等；</li>
<li>DEFAULT：用于保证该字段有默认值；</li>
<li>PRIMARY KEY：主键约束，用于保证该字段的值具有唯一性，并且非空；</li>
<li>UNIQUE：唯一，用于保证该字段的值具有唯一性，但可以为空；比如座位号；</li>
<li>CHECK：检查约束，【mysql中不支持】；比如年龄、性别（性别只能有男女）</li>
<li>FOREIGN KEY：外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值；<br> 在从表中添加外键约束，用于引用主表中的某列的值；<br> 比如：学生表的专业编号，员工表的部门编号等；</li>
</ol>
</li>
<li><p>添加约束的时机：</p>
<ol>
<li>创建表时；</li>
<li>修改表时；</li>
</ol>
</li>
<li><p>约束的添加分类：</p>
<ol>
<li>列级约束；<ul>
<li>在语法上六大约束都支持，但外键约束没有效果</li>
</ul>
</li>
<li>表级约束；<ul>
<li>除了非空、默认，其他的都支持；</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="1-创建表时添加约束"><a href="#1-创建表时添加约束" class="headerlink" title="1.创建表时添加约束"></a>1.创建表时添加约束</h4><h5 id="1-添加列级约束"><a href="#1-添加列级约束" class="headerlink" title="1.添加列级约束"></a>1.添加列级约束</h5><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table stuinfo(</span><br><span class="line">	id int primary key,#主键</span><br><span class="line">	stuName varchar(20) not null,# 非空</span><br><span class="line">	gender char(1) check(gender=&#x27;男&#x27; or gender=&#x27;女&#x27;),#检查</span><br><span class="line">	seat int unique,# 唯一</span><br><span class="line">	age int default 18,#默认</span><br><span class="line">	majorId int references major(id)#外键	（mysql不支持）	</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
**show index from stuinfo** 查看stuinfo表中所有的索引；
</code></pre>
<h5 id="2-添加表级约束"><a href="#2-添加表级约束" class="headerlink" title="2.添加表级约束"></a>2.添加表级约束</h5><ul>
<li>语法：在各个字段的最下面<br>【contraint 约束名】  约束类型(字段名)<br>  create table stuinfo(<br>  id int,<br>  stuName varchar(20),<br>  gender char(1),<br>  seat int,<br>  age int,<br>  majorId int<br>  CONSTRAINT pk PRIMARY KEY(id),<br>  CONSTRAINT uq UNIQUE(seat),<br>  CONSTRAINT ck check(gender&#x3D;’男’ or gender&#x3D;’女’),<br>  CONSTRAINT fk_stuinfo_major FROEIGN KEY(majorid) references major(id)#外键<br>  );</li>
</ul>
<p><strong>最好外键约束写成表级的，其他约束写成列级的</strong></p>
<blockquote>
<p>主键和唯一的对比：<br>	保证唯一性	是否允许为空	一个表中可以有多少个	是否允许组合（不推荐使用）<br>主键	√		×		最多一个		允许（PRIMARY KEY(id,stuName)）<br>唯一	√		√		可以多个		允许（和主键一样）</p>
</blockquote>
<ul>
<li>外键：<ol>
<li>要求在从表设置外键关系；</li>
<li>从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称则无要求；</li>
<li>主表中的关联列必须是一个key(一般是主键或唯一键)；</li>
<li>插入数据时，先插入主表，再插入从表；删除数据时，先删除从表，再删除主表；</li>
</ol>
</li>
</ul>
<h4 id="2-修改表时添加约束"><a href="#2-修改表时添加约束" class="headerlink" title="2.修改表时添加约束"></a>2.修改表时添加约束</h4><ul>
<li>添加列级约束：<br>  <code>alter table 表名 modify column 字段名 字段类型 新约束;</code></li>
<li>添加表级约束：<br>  <code>alter table 表名 add 【constraint 约束名】 约束类型(字段名);</code></li>
</ul>
<p><code>alter table stuinfo modify column stuname varchar(20) NOT NULL;</code><br><code>alter table stuinfo modify column age int default 18;</code><br><code>alter table stuinfo modify column id int primary key;</code><br>或者：<br><code>alter table stuinfo add primary key(id);</code></p>
<h4 id="3-修改表时删除约束"><a href="#3-修改表时删除约束" class="headerlink" title="3.修改表时删除约束"></a>3.修改表时删除约束</h4><h3 id="标识列"><a href="#标识列" class="headerlink" title="标识列"></a>标识列</h3><blockquote>
<p>又称为自增长列，可以不用手动的插入值，系统提供默认的序列值；</p>
</blockquote>
<ul>
<li>特点：<ol>
<li>标识列必须和key搭配（主键或unique键或外键）；</li>
<li>一个表中最多只能有一个自增长列；</li>
<li>标识列的类型只能是数值型；（int float double）</li>
<li>标识列可以通过<code>set auto_increment_increment=3;</code>设置步长，还可以通过手动插入值设置起始值；</li>
</ol>
</li>
</ul>
<ol>
<li>创建表时设置标识列 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table tab_identity(</span><br><span class="line">	ind int primary key auto_increment,</span><br><span class="line">	name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
 <code>show variables like &#39;%auto_increment%&#39;</code>;  显示自增长的起始值和步长；<br> <code>set auto_increment_increment=3;</code>  设置自增长的步长</li>
</ol>
<h2 id="四、TCL"><a href="#四、TCL" class="headerlink" title="四、TCL"></a>四、TCL</h2><blockquote>
<p>transaction control language 事物控制语言<br>事务：一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行<br>要么全部不执行；整个单独单元作为一个不可分割的整体，如果单元中<br>某条sql语句一旦执行失败或产生错误，整个单元将会回滚。所有受到<br>影响的数据将返回到事务开始以前的状态；如果单元中的所有sql语句均<br>执行成功，则事物被顺利执行；</p>
</blockquote>
<ul>
<li>事务的acid属性：<ol>
<li>原子性(Atomicity)：指事务是一个不可分割的工作单位，事务中的操作<strong>要么同时执行，要么都不执行</strong>；</li>
<li>一致性(Consistency)：事务必须使数据库从一个一致性状态变换到另外一个一致性状态；</li>
<li>隔离性(Isolation)：事务的隔离性是指一个事务的执行不能被其他食物干扰，即一个事务内部的操作及<br>     使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
<li>持久性(Durability)：一个事务一旦被提交，它对数据库的改变就是永久性的，接下来的其他操作和数据<br>     库故障不应该对其有任何影响；</li>
</ol>
</li>
<li>事务的创建：<ol>
<li><p>隐式事务：事务没有明显的开启和结束的标记；比如insert、update、delete语句 </p>
</li>
<li><p>显式事务：事务没有明显的开启和结束的标记；<br> 前提：必须先设置自动提交功能为禁用；set autocommit&#x3D;0;</p>
<p> 步骤1：开启事务<br> set auto commit&#x3D;0;<br> start transaction;  可选<br> 步骤2：编写事务中的sql语句(select insert update delete)<br> 语句1；<br> 语句2；<br> …<br> 步骤3：结束事务<br> commit;提交事务<br> rollback；回滚事务<br> 提交和回滚都算结束事务；</p>
<ul>
<li>演示事务的使用步骤：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 开启事务</span><br><span class="line">set auto commit=0;</span><br><span class="line">start transaction;</span><br><span class="line"># 编写一组事务的语句</span><br><span class="line">update account set balance = 500 where username = &#x27;张无忌&#x27;;</span><br><span class="line">update account set balance = 1500 where username = &#x27;赵敏&#x27;；</span><br><span class="line"># 结束事务</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></li>
<li>回滚点：savepoint;(搭配rollback使用)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set autocommitt=0;</span><br><span class="line">start transaction;</span><br><span class="line">delete from account where id=25;</span><br><span class="line">savepoint a; #设置保存点</span><br><span class="line">delete from account where id=28;</span><br><span class="line">rollback to a; #回滚到保存点</span><br><span class="line">#25号删了；28 没删</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li>数据库的隔离级别<br>  对于同时运行的多个事务，当这些事务访问数据库相同的数据时，如果没有采取必要的<br>  隔离措施，就会导致各种并发问题：<br>  1. 脏读：两个事务T1、T2，T1读取了已经被T2更新但还没提交的字段之后，若T2回滚，T1读取的内容就是临时且无效的；<br>  2. 不可重复读：T1读取了一个字段，然后T2更新了该字段之后，T1再次读同一个字段，值就不同了；<br>  3. 幻读：T1从一个表中读取了一个字段，然后T2在该表中插入了一些新的行，如果T1再次读取同一个表，就会多出几行；<br>  数据事务的隔离性：数据库系统必须具有隔离并发运行的哥哥事物的能力，使它们之间不会相互影响，避免各种并发问题；<br>  一个事务与其他事务隔离的成都成为隔离级别。隔离级别越高，数据一致性越好，但并发性越弱；<br>  1. read uncommitted(读未提交数据)：允许事务读取未被其他事务提交的变更。脏读、不可重复读和幻读的问题都会出现；<br>  2. read committed(读已提交数据)：只允许事务读取已经被其他事务提交的变更。可以避免脏读，但不可重复读和幻读的问题仍然可能出现；<br>  3. repeadable read(可重复读)：确保事务可以多次从一个字段中读取相同的值。在这个事务持续期间，禁止其他事务对这个字段进行更新。可以避免脏读和不可重复读。幻读仍存在；<br>  4. serializable(串行化)：确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下；<br>  查看当前的隔离级别：<code>select@@tx_isolation;</code><br>  设置当前mysql连接的隔离级别：<code>set transaction isolation level READ COMMITTED;</code><br>  设置数据库系统的全局的隔离级别：<code>set global transaction isolation level read committed;</code></li>
</ul>
<h3 id="视图；"><a href="#视图；" class="headerlink" title="视图；"></a>视图；</h3><p><strong>有点像封装的方法（也就是函数）</strong></p>
<blockquote>
<p>虚拟表，和普通表一样使用。仅保存查询逻辑，不保存查询结果。并动态生成临时查询的结果表。</p>
</blockquote>
<ul>
<li>应用场景：<ol>
<li>多个地方用到同样的查询结果；</li>
<li>该查询结果使用的sql语句较复杂；</li>
</ol>
</li>
<li>创建视图的语法：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create view 视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure></li>
<li>视图的好处：<ol>
<li>实现了sql语句的重用；</li>
<li>简化复杂的sql操作，不必知道它的查询细节；</li>
<li>保护数据，提高安全性；</li>
</ol>
</li>
<li>视图的修改：<br>  方式1：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create or replace view 视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure><br>  方式2：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter view 视图名</span><br><span class="line">as </span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure></li>
<li>删除视图：<br>  语法：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view 视图名1，视图名2...</span><br></pre></td></tr></table></figure></li>
<li>查看视图：<br>  语法：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">desc 视图名;</span><br><span class="line">或</span><br><span class="line">show create view 视图名;</span><br></pre></td></tr></table></figure></li>
<li>案例1：创建视图emp_v1，要求查询电话号码以’011’开头的员工姓名和工资、邮箱；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create or replace view emp_v1</span><br><span class="line">as </span><br><span class="line">select last_name,salary,email</span><br><span class="line">from employees</span><br><span class="line">where phone_number like &#x27;011%&#x27;;</span><br></pre></td></tr></table></figure></li>
<li>案例2：创建视图emp_v2,要求查询部门的最高工资高于12000的部门信息；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create or replace view emp_v2</span><br><span class="line">as </span><br><span class="line">#最高工资高于12000的部门名</span><br><span class="line">select max(salary) mx_dep,department_id</span><br><span class="line">from employees</span><br><span class="line">group by department_id</span><br><span class="line">having mx_dep&gt;12000;</span><br><span class="line"></span><br><span class="line">select d.*,m.mx_dep </span><br><span class="line">from departments d</span><br><span class="line">inner join emp_v2 m</span><br><span class="line">on d.department_id = m.department_id;</span><br></pre></td></tr></table></figure></li>
<li>视图的更新：<br>  一般不用；语法和表的更新一样 insert into ;delete; update;</li>
</ul>
<h2 id="五、常见的数据类型："><a href="#五、常见的数据类型：" class="headerlink" title="五、常见的数据类型："></a>五、常见的数据类型：</h2><ol>
<li>数值型：<ul>
<li>整型:</li>
<li>小数：<ol>
<li>定点数</li>
<li>浮点数</li>
</ol>
</li>
</ul>
</li>
<li>字符型：<ul>
<li>较短的文本：char、varchar</li>
<li>较长的文本：text、blob（较长的二进制数据）</li>
</ul>
</li>
<li>日期型：</li>
</ol>
<h3 id="1-整型"><a href="#1-整型" class="headerlink" title="1. 整型"></a>1. 整型</h3><p>分类：<br>	tinyint、smallint、mediumint、int&#x2F;integer、bigint<br>字节数	1	  2		3	4	    8	</p>
<ul>
<li>特点：<ol>
<li>如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字；</li>
<li>如果插入超出了整型的范围，会报out of range异常，并且插入临界值；</li>
<li>如果不设置长度，会有默认的长度；</li>
</ol>
</li>
</ul>
<h3 id="2-小数"><a href="#2-小数" class="headerlink" title="2. 小数"></a>2. 小数</h3><ul>
<li>分类：<ol>
<li>浮点型：<br> float(M,D)<br> double(M,D)  </li>
<li>定点型：<br> dec(M,D)<br> decimal(M,D)</li>
</ol>
</li>
<li>特点：<br>  1.<br>  M：整数部位+小数部位<br>  D：小数部位<br>  如果超过范围，则插入临界值；<br><br>  2.<br>  M和D都可以省略；<br>  如果是decimal，则M默认为10，D默认为0；<br>  如果是float和double，则会根据插入的数值的精度来决定精度；</li>
</ul>
<h3 id="3-字符型"><a href="#3-字符型" class="headerlink" title="3. 字符型"></a>3. 字符型</h3><h3 id="2-日期"><a href="#2-日期" class="headerlink" title="2. 日期"></a>2. 日期</h3><ul>
<li>分类：<ol>
<li>date        只有日期</li>
<li>datetime    日期和时间    </li>
<li>timestamp    某个时刻（时间戳）</li>
<li>time        只有时间</li>
<li>year        只有年份</li>
</ol>
</li>
</ul>
<h2 id="六、变量"><a href="#六、变量" class="headerlink" title="六、变量"></a>六、变量</h2><h3 id="1-系统变量"><a href="#1-系统变量" class="headerlink" title="1. 系统变量"></a>1. 系统变量</h3><blockquote>
<p>由系统提供，不是用户定义，属于服务器层面；</p>
</blockquote>
<ul>
<li>语法<ol>
<li>查看所有的系统变量:<code>show global | session variables;</code></li>
<li>查看满足条件的部分系统变量：<code>show global | session variables like &#39;%char%&#39;;</code></li>
<li>查看指定的某个系统变量的值：<code>select @@global | session.系统变量名;</code></li>
<li>为某个系统变量赋值: <code>set global | session 系统变量名 = 值;</code></li>
</ol>
</li>
</ul>
<h4 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1. 全局变量"></a>1. 全局变量</h4><h4 id="2-会话变量"><a href="#2-会话变量" class="headerlink" title="2. 会话变量"></a>2. 会话变量</h4><h3 id="2-自定义变量"><a href="#2-自定义变量" class="headerlink" title="2.自定义变量"></a>2.自定义变量</h3><h4 id="1-用户变量"><a href="#1-用户变量" class="headerlink" title="1. 用户变量"></a>1. 用户变量</h4><blockquote>
<p>用户自定义<br>使用步骤：声明 赋值  使用<br>作用域：针对当前会话（连接） 有效，等同于会话变量的作用域；</p>
</blockquote>
<ul>
<li>声明并初始化：<br>  <code>set @用户变量名=值;</code><br>  <code>set @用户变量名:=值;</code><br>  <code>select @用户变量名:=值;</code></li>
<li>赋值：<br>  方式1：<br>  <code>set @用户变量名=值;</code><br>  <code>set @用户变量名:=值;</code><br>  <code>select @用户变量名:=值;</code><br>  方式2：<br>  <code>select 字段 into 变量名 from 表;</code></li>
<li>查看<br>  <code>select @用户变量名;</code></li>
</ul>
<h4 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2. 局部变量"></a>2. 局部变量</h4><ul>
<li>声明：<br>  <code>declare 变量名 类型;</code><br>  <code>declare 变量名 类型 default 值;</code></li>
</ul>
<h2 id="七、存储过程和函数"><a href="#七、存储过程和函数" class="headerlink" title="七、存储过程和函数"></a>七、存储过程和函数</h2><ul>
<li>创建存储过程：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create procedure 存储过程名(参数)</span><br><span class="line">begin</span><br><span class="line">	存储过程体(一组合法的sql语句)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：参数列表包含三部分：参数模式 参数名 参数类型</li>
</ul>
<ol>
<li>参数模式：<ul>
<li>in：该参数可以作为输入，需要调用方传入值</li>
<li>out：该参数可以作为输出，可以作为返回值</li>
<li>inout：即可做输入，又可做输出。即需要传入值，有需要返回值；</li>
</ul>
</li>
<li>如果存储过程体只有一句话，begin end可以省略；</li>
<li>存储过程体的每条sql的结尾要求必须加分号；存储过程的结尾可以使用DELIMITER重新设置；<br> DELIMITER $</li>
</ol>
</li>
<li>调用语法：<br>  <code>CALL 存储过程名(实参列表);</code></li>
<li>创建函数：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create function 函数名(参数列表) returns 返回类型</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="八、流程控制结构"><a href="#八、流程控制结构" class="headerlink" title="八、流程控制结构"></a>八、流程控制结构</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/08/jvm%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fremont">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="有间栈">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 有间栈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/08/jvm%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">jvm常见问题-历史学习记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-08 22:39:36 / 修改时间：22:44:08" itemprop="dateCreated datePublished" datetime="2025-06-08T22:39:36+08:00">2025-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">历史学习记录</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>37 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JVM-常见问题总结"><a href="#JVM-常见问题总结" class="headerlink" title="JVM 常见问题总结"></a>JVM 常见问题总结</h1><h3 id="3-JAVA内存如何分配？"><a href="#3-JAVA内存如何分配？" class="headerlink" title="3. JAVA内存如何分配？"></a>3. JAVA内存如何分配？</h3><blockquote>
<p>Java内存可以分为程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区这几个部分。其中程序计数器、Java虚拟机栈、本地方法栈属于线程私有，而Java堆和方法区属于线程共享区域。对于Java的堆内存可以划分为新生代和老年代。在新生代中划分为一个Eden区和两个Survivor区。创建一个Java对象时，会通过指针碰撞或空闲列表法为对象分配内存。而当我们访问一个对象的时候可以通过句柄或者直接地址的方式进行对象的访问。</p>
</blockquote>
<h3 id="4-画出java运行时内存区结构图"><a href="#4-画出java运行时内存区结构图" class="headerlink" title="4. 画出java运行时内存区结构图"></a>4. 画出java运行时内存区结构图</h3><ul>
<li>程序计数器</li>
<li>java虚拟机栈</li>
<li>本地方法栈</li>
<li>java堆</li>
<li>方法区  <ol>
<li>运行时常量池</li>
</ol>
</li>
<li>直接内存<blockquote>
<p>前三个是线程私有的，java堆和方法区由所有线程共享。直接内存并不是java虚拟机运行时数据区域的一部分，但其中包括NIO类。</p>
</blockquote>
</li>
</ul>
<ol>
<li>程序计数器可看作是当前线程所执行字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，是程序控制流的指示器，分支、循环、跳转、异常处理等基础功能都需要依赖该计数器；此外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器；</li>
<li>Java虚拟机栈的生命周期与线程相同，描述的是java方法执行的线程内存模型：每个方法执行的时候，java虚拟机就会同步创建一个栈帧来存储该方法的局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法从调用直至执行完毕的过程，就对应着一个栈帧再虚拟机中从入栈到出栈的过程。</li>
<li>本地方法栈： 和虚拟机栈类似，虚拟机栈为虚拟机执行java方法（也就是字节码服务），本地方法栈为虚拟机执行本地方法服务。</li>
<li>java堆：虚拟机启动时创建。唯一目的就是存放对象实例，几乎所有对象实例都在这里分配内存。也是垃圾收集器管理的内存区域，因此也被称为（GC堆）</li>
<li>方法区：用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</li>
</ol>
<h3 id="5-堆区如何分类"><a href="#5-堆区如何分类" class="headerlink" title="5. 堆区如何分类"></a>5. 堆区如何分类</h3><ul>
<li>设计者一般至少把Java堆划分为新生代和老年代两个区域。</li>
<li><strong>对于新生代</strong>，如果采用Appel标记-复制算法，会把新生代分为Eden和两个Survivor区，Eden:Survivor &#x3D; 8：1。并一般用老年代来做分配担保。</li>
<li>G1收集器是基于Region的内存布局。</li>
</ul>
<h3 id="6-堆与栈区别"><a href="#6-堆与栈区别" class="headerlink" title="6. 堆与栈区别"></a>6. 堆与栈区别</h3><ol>
<li>堆存储的是对象。</li>
<li>栈对应的是调用的方法，每一个方法从调用到结束就对应着一个栈帧在栈中从入栈到出栈的过程。</li>
</ol>
<h3 id="7-为什么要把字符串常量池放到堆区"><a href="#7-为什么要把字符串常量池放到堆区" class="headerlink" title="7. 为什么要把字符串常量池放到堆区"></a>7. 为什么要把字符串常量池放到堆区</h3><br/> 
<br/> 
<br/>

<h3 id="8-java8方法区的变化"><a href="#8-java8方法区的变化" class="headerlink" title="8. java8方法区的变化"></a>8. java8方法区的变化</h3><blockquote>
<p>JDK7之前，HotSpot使用永久代来实现方法区时，类变量（也就是静态变量，被static修饰的变量）所使用的内存都应该在方法区中进行分配，方法区本身是一个逻辑上的区域。而在JDK之后，类变量会随着Class对象一起存放在Java堆中。</p>
</blockquote>
<h3 id="9-判断对象已经无效"><a href="#9-判断对象已经无效" class="headerlink" title="9. 判断对象已经无效"></a>9. 判断对象已经无效</h3><ul>
<li><p>引用计数器：<br>　　在对象中加一个引用计数器，每当有一个地方引用它，计数器就加1；引用失效时就减1；任何时刻计数器为0的对象就是不可能再被引用的。</p>
</li>
<li><p>可达性分析：<br>　　通过一系列成为“GC roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径成为“引用链”，如果某对象到GC roots间没有任何引用链连接，或者说从GC roots到该对象不可达时，则证明此对象是不可能再被使用的。</p>
</li>
</ul>
<h3 id="10-引用计数法实现原理"><a href="#10-引用计数法实现原理" class="headerlink" title="10. 引用计数法实现原理"></a>10. 引用计数法实现原理</h3><ol>
<li>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为0的对象就是不可能再被使用的。</li>
<li>虽然占用了一些额外的内存空间来进行计数，但原理简单，效率较高。但无法解决循环引用问题；</li>
</ol>
<h3 id="11-哪些对象可以作为GC-Root"><a href="#11-哪些对象可以作为GC-Root" class="headerlink" title="11. 哪些对象可以作为GC Root"></a>11. 哪些对象可以作为GC Root</h3><blockquote>
<p>GC roots应是一组活跃的引用；</p>
</blockquote>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的native方法）中引用的对象</li>
<li>java虚拟机内部的引用</li>
<li>所有被同步锁持有的对象</li>
<li>反应java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ol>
<h3 id="12-GCRoot详细"><a href="#12-GCRoot详细" class="headerlink" title="12. GCRoot详细"></a>12. GCRoot详细</h3><ol>
<li>固定可作为GC Roots的节点主要在全局性的引用与执行上下文中，尽管目标明确，但高效的查找到这些节点并不容易；</li>
<li>尽管可达性分析算法中耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但根节点枚举这一步骤都是必须暂停用户进程的，也就是Stop The World；而且根节点枚举还是必须在一个能保障一致性的快照中才得以进行。</li>
<li>在类加载动作完成的时候，HotSpot就会通过一种OopMap的数据结构把对象内什么偏移量上存放的是什么类型的数据给计算出来，在即时编译的过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏的从方法区等GC Roots开始查找。</li>
<li>在OopMap（一种可以直接得到那些地方存放着对象引用的数据结构）的帮助下，HotSpot可以快速准确的完成GC Roots枚举。</li>
</ol>
<h3 id="13-finalize-方法回收对象的两次标记过程"><a href="#13-finalize-方法回收对象的两次标记过程" class="headerlink" title="13. finalize()方法回收对象的两次标记过程"></a>13. finalize()方法回收对象的两次标记过程</h3><ul>
<li>即使在可达性分析中判定为不可达的对象，也不是非死不可的。要真正宣告一个对象死亡，最多会经历两次标记过程；</li>
</ul>
<ol>
<li>如果对象在进行可达性分析后发现没有和GC roots相连接的引用链，那它将会被第一次标记。随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。如果对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为没有必要执行。</li>
<li>如果对象被判定为有必要执行finalize()方法，那么该对象将会被放置到F-Queue队列之中。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的队列进行第二次标记。如果想拯救自己，只需重新与引用链上的任何一个对象建立关联即可。</li>
</ol>
<h3 id="14-Java四种引用及场景"><a href="#14-Java四种引用及场景" class="headerlink" title="14. Java四种引用及场景"></a>14. Java四种引用及场景</h3><ol>
<li>强引用:<br> 　最传统的引用定义，指在程序代码中普遍存在的引用赋值。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象；</li>
<li>软引用：<br>　　用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收后还没有足够的内存，才会抛出内存溢出异常； softreference类</li>
<li>弱引用：<br>　　描述非必须对象，但他的强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。weakreference类</li>
<li>虚引用：<br>　　“幽灵引用”、“幻影引用”，是最弱的一种引用关系，是否有虚引用存在完全不会对对象的生存时间构成影响，为一个对象设置虚引用的唯一目的只是为了在这个对象被收集器回收时受到一个系统通知。phantomreference类</li>
</ol>
<h3 id="15-垃圾回收算法和流程"><a href="#15-垃圾回收算法和流程" class="headerlink" title="15. 垃圾回收算法和流程"></a>15. 垃圾回收算法和流程</h3><blockquote>
<p>垃圾收集算法可分为引用计数式垃圾收集和追踪式垃圾收集两大类，这两大类也被称为直接垃圾收集和间接垃圾收集。下面的所有算法都是Tracing GC</p>
</blockquote>
<ul>
<li>分代收集理论：<ol>
<li>弱分代假说：绝大多数对象都是朝生夕灭的；</li>
<li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡；</li>
<li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数；<ul>
<li>依据这个假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全集的数据结构（记忆集），这个结构把老年代划分成若干个小块，标识出老年代哪一些内存中会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC roots进行扫描。</li>
</ul>
</li>
</ol>
</li>
</ul>
<ol>
<li><p>标记-清除算法：</p>
<ul>
<li>算法分为标记和清除两个阶段： 首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象；也可以反过来，标记存活的对象，回收所有未被标记的对象。</li>
<li>缺点：1.执行效率不稳定，如果java堆中包括大量对象，而且其中大部分是需要被回收的，这时就需要大量的标记和清除操作，导致执行效率随对象数量的增长而降低；2. 内存空间的碎片化问题，标记清除后会产生大量不连续的内存碎片，碎片太多可能导致程序运行过程中无法为较大对象分配足够的连续内存，从而不得不提前触发另一次垃圾收集动作。</li>
</ul>
</li>
<li><p>标记-复制算法：</p>
<ul>
<li>为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，提出“半区复制”的垃圾收集算法，将可用内存划分为大小相等的两块，每次只是有其中的一块。当这一块用完了，就把还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种算法的代价可用内存只有原来的一半，空间浪费严重。</li>
<li>“Appel式回收”，一种更优化的半区复制分代策略。Serial Parnew等新生代收集器都采用这种策略来设计新生代的内存布局。具体做法是把新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。当发生垃圾收集时，把Eden和Survivor中仍然存活的对象都复制到另一块Survivor空间上，然后直接清理掉Eden和Survivor空间。默认Eden：survivor &#x3D; 8：1；<ul>
<li><strong>逃生门设计</strong>：当Survivor空间不足以容纳一次Minor GC之后的存活对象时，就需要依赖其他内存区域（大多是老年代）进行分配担保。这些容纳不下的对象通过分配担保机制直接进入老年代。</li>
</ul>
</li>
</ul>
</li>
<li><p>标记-整理算法：</p>
<ul>
<li>标记-复制算法在对象存活率较高的时候就会有较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就要有额外的空间进行分配担保，因此老年代一般不能直接选用这种算法。</li>
<li>标记-整理算法的标记过程和标记-清除的标记过程一样，但后续步骤不是对所有被标记的对象进行清理，而是把所有存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存。</li>
<li>标记整理的缺点：在老年代这种每次回收都有大部分对象存活的区域，移动存活对象并更新引用这些对象的地方是一项十分负重的操作，必须停止用户程序才能进行，也就是Stop The World。<strong>会增大延迟</strong></li>
<li>标记清除的缺点：空间碎片化问题要依靠更发杂的内存分配器和内存访问器来解决，<strong>会直接影响吞吐量。</strong></li>
</ul>
</li>
</ol>
<blockquote>
<p>因此更关注吞吐量的Parallel Old收集器是基于标记-整理算法的，而更关注低延迟的CMS收集器采用标记-清除算法。准确来说，CMS采用的是一种折中的算法：让虚拟机平时多数时间采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化成都已经大到影响对象分配时，再用标记-整理算法收集一次，以获得规整的内存空间。</p>
</blockquote>
<h3 id="16-如何减少full-gc的次数？"><a href="#16-如何减少full-gc的次数？" class="headerlink" title="16. 如何减少full gc的次数？"></a>16. 如何减少full gc的次数？</h3><blockquote>
<p>首先应明确为什么会发生full gc：当内存回收的速度赶不上内存分配的速度时，就会导致full gc，长时间stop the world.比如在CMS中的”Concurrent Mode Failure”失败。</p>
</blockquote>
<br/> 



<h3 id="17-方法区是否需要gc"><a href="#17-方法区是否需要gc" class="headerlink" title="17. 方法区是否需要gc"></a>17. 方法区是否需要gc</h3><blockquote>
<p>java虚拟机规范中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上有未实现或未能完整实现方法去类型卸载的收集器存在。方法区垃圾收集因为判定条件比较苛刻，因此性价比低。</p>
</blockquote>
<ul>
<li>方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。<ol>
<li>回收废弃的常量与回收java中的对象非常类似。  </li>
<li>判定一个类型是否是不再使用的需要满足三个条件：  <ol>
<li>该类所有的实例都已经被回收，也就是说Java堆中不存在该类及其任何派生子类的实例；</li>
<li>加载该类的类加载器已经被回收；</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该对象。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="18-查看GC状态的命令"><a href="#18-查看GC状态的命令" class="headerlink" title="18. 查看GC状态的命令"></a>18. 查看GC状态的命令</h3><ul>
<li>jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令的格式如下：</li>
<li>jstat [-命令选项] [vmid] [间隔时间&#x2F;毫秒] [查询次数]<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/jek123456/article/details/80432449">CSDN</a></li>
</ul>
<h3 id="19-CMS收集器的流程"><a href="#19-CMS收集器的流程" class="headerlink" title="19. CMS收集器的流程"></a>19. CMS收集器的流程</h3><blockquote>
<p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器。基于标记-清除算法。主要流程有：1)初始标记；2)并发标记；3)重新标记；4)并发清除。其中初始标记和重新标记两个步骤需要Stop the World。</p>
</blockquote>
<ol>
<li>初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；个人理解有点像根节点枚举过程，需要stop the world，但根节点枚举的意思好像是找出GC Roots对象，而初始标记标记的是和roots直接关联的对象，所以还是不太一样吧。</li>
<li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时很长但是不需要停顿用户线程，能与垃圾收集线程一起并发运行；</li>
<li>重新标记：为了修正并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录。</li>
<li>并发清除：清理删除掉标记阶段判断已经死亡的对象，由于不需要移动存活对象（因为CMS采用的是标记-清除算法），所以这个阶段也是可以与用户线程并发的。</li>
</ol>
<h3 id="20-G1收集器的流程"><a href="#20-G1收集器的流程" class="headerlink" title="20. G1收集器的流程"></a>20. G1收集器的流程</h3><blockquote>
<p>G1收集器是一款面向服务端应用的垃圾收集器，开创了收集器面向局部收集的设计思路和基于Region的内存布局格式。能实现停顿时间模型，可以由用户指定期望的停顿时间使得G1在不同的场景下取得关注吞吐量和关注延迟之间的最佳平衡。</p>
</blockquote>
<ul>
<li>停顿时间模型：能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。</li>
<li>Mixed GC模式：G1收集器之前的垃圾收集器，包括CMS在内，垃圾收集的目标要么是整个新生代（Minor GC），要么是整个老年代（Major GC），要么就是整个Java堆（Full GC）。而G1跳出了这个樊笼，它可以面对堆内存的任何部分来组成回收集（Collection Set），衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾最多，回收收益最大，这就是G1的Mixed GC模式。</li>
<li><strong>G1开创的基于Region的堆内存布局是它能够实现这个目标的关键</strong>。虽然G1仍遵循分代收集理论，但其堆内存布局和其他收集器有明显差异：不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。这样无论是新对象还是存活了一段时间的旧对象都能获得较好的收集效果。</li>
<li>Region中还有一类特殊的Humongous区域，专门用来存储大对象。</li>
<li>虽然G1 还保留分代收集理论的思想，但是新生代和老年代不再固定，而是一系列Region区域的动态组合。<blockquote>
<p>总结：G1收集器之所以能建立可预测的停顿时间模型，<strong>是因为它将Region作为单次回收的最小单元</strong>，即每次收集到的内存空间都是Region大小的整数倍，这样就可以有计划的避免在整个Java堆中进行全区域的垃圾收集。具体思路：让G1收集器去跟踪各个Region里面的垃圾堆积的价值大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，根据用户设定的停顿时间，优先处理回收价值收益最大的那些Region。<strong>使用Region划分内存空间，以及具有优先级的区域回收方式保证了G1收集器在有限时间内获取尽可能高的收集效率</strong></p>
</blockquote>
</li>
<li>G1实现细节：  <ol>
<li>跨Region指针如何处理：每个Region都维护有自己的记忆集，记录着别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围内。这种双向卡表结构（记录我指向谁和谁指向我）实现起来更加复杂，Region分代数量比传统的多也造成卡表多，因此G1有更高的内存占用负担。</li>
<li><strong>并发标记阶段如何保证收集线程和用户线程能互不干扰的进行</strong>：CMS采用增量更新，G1采用原始快照（SATB）。G1为每一个Region都创建了两个TAMS的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新对象的分配地址要在两个指针位置以上，默认是存活的，不纳入回收范围。</li>
<li>如何建立可靠的停顿预测模型：以衰减均值为理论基础实现。</li>
</ol>
</li>
<li>流程：<ol>
<li><strong>初始标记</strong>：仅仅标记一下GC Roots能直接关联到的对象，并修改TAMS指针的值，让下阶段用户线程并发运行时，能正确地在可用的Region上分配新对象。需要停顿线程，但耗时短，而且是借用Minor GC的时候同步完成的，所以G1收集器在这个地方没有额外的停顿。</li>
<li><strong>并发标记</strong>：从GC Root开始对堆中的对象进行可达性分析，递归的扫描整个堆里的对象图，找出要回收的对象。耗时长，但可以与用户线程并发进行。对象图扫描完后，还要重新处理SATB记录下的在并发时有引用变动的对象。</li>
<li><strong>最终标记</strong>：stop the world，处理并发阶段结束后遗留的少量的SATB记录。</li>
<li><strong>筛选回收</strong>：更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空Region中，再清理掉旧Region的全部空间（标记-复制垃圾收集算法）。涉及到了对象的移动，所以要stop the world。</li>
</ol>
</li>
</ul>
<h3 id="21-CMS收集器和G1收集器的区别"><a href="#21-CMS收集器和G1收集器的区别" class="headerlink" title="21. CMS收集器和G1收集器的区别"></a>21. CMS收集器和G1收集器的区别</h3><blockquote>
<p>G1收集器可以指定最大停顿时间，分Region布局，按收益动态确定回收集，且不会产生内存碎片，有利于程序长时间运行。G1的卡表比CMS的复杂，内存占用负担较重。CMS只使用了写后屏障，G1使用写前、写后屏障。</p>
</blockquote>
<ol>
<li><strong>采用的垃圾收集算法不同</strong>：CMS平时多数时间采用标记-清除算法，当内存空间的碎片程度影响到内存分配时，再采用标记-整理算法收集一次。而G1收集器采用整体上看标记-整理、局部看标记-复制算法，不会产生内存碎片。</li>
<li>内存布局不同：CMS是传统的新生代、老年代布局，G1是基于Region的内存布局；</li>
<li>垃圾收集的作用域不同：CMS要么Minor GC要么Major GC要么Full GC，而G1是局部收集思路，衡量标准不再是属于哪个分代，二十那块内存的回收收益最大，也就是Mixed GC。</li>
<li>为了实现并发标记阶段所采用的方法不同：CMS是基于增量更新的方法；而G1是原始快照（SATB）；</li>
</ol>
<h3 id="22-内存管理-对象创建、布局、访问定位"><a href="#22-内存管理-对象创建、布局、访问定位" class="headerlink" title="22. 内存管理(对象创建、布局、访问定位)"></a>22. 内存管理(对象创建、布局、访问定位)</h3><h4 id="1-对象的创建过程"><a href="#1-对象的创建过程" class="headerlink" title="1. 对象的创建过程"></a>1. 对象的创建过程</h4><ol>
<li>java虚拟机遇到一个new指令时，首先检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查符号引用所代表的类是否已经被加载、解析和初始化过，如果没有，执行类加载过程；</li>
<li>类加载检查通过后，虚拟机将为对象分配内存。对象所需内存的大小在类加载完成时便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从java堆中划分出来。（分配方式有指针碰撞、空闲列表，还要考虑分配内存时并发情况下的线程安全问题：对分配内存动作进行同步处理，或把内存分配的动作按照线程划分在不同空间中进行</li>
<li>内存分配完成后，虚拟机将分配到的内存（除了对象头）都初始化为0，保证对象的实例字段在java代码中不赋初始值就能直接使用。</li>
<li>设置对象头，如是哪个类的实例、如何找到类的元数据信息、GC分代年龄等。</li>
<li>new指令后接着会执行&lt;\init&gt;()方法，按照程序员的意愿对对象进行初始化。</li>
</ol>
<h4 id="2-对象布局"><a href="#2-对象布局" class="headerlink" title="2. 对象布局"></a>2. 对象布局</h4><blockquote>
<p>对象在堆内存中的存储布局可以划分为三部分：对象头、实例数据和对齐填充</p>
</blockquote>
<ol>
<li>对象头：  包括两类信息  <ul>
<li>第一类是用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁等；</li>
<li>第二类是类型指针，即对象指向它的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例。但并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。</li>
</ul>
</li>
<li>实例数据：  <ul>
<li>是对象真正存储的有效信息，即我们在代码里所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录下来。</li>
</ul>
</li>
<li>对齐填充：<ul>
<li>并不是必然存在的，仅仅起着占位符的作用。</li>
</ul>
</li>
</ol>
<h4 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3. 对象的访问定位"></a>3. 对象的访问定位</h4><blockquote>
<p>java程序会通过栈上的reference数据来操作堆上的具体对象。<br>主流的访问方式主要有两种：</p>
</blockquote>
<ul>
<li>使用句柄：java堆中划分出一块内存座位句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自具体的地址信息；好处是对象被移动时只需要改变句柄中的实例数据指针，而不用改变reference。</li>
<li>使用直接指针：reference中存储的直接就是对象地址。好处是速度快，节省了一次指针定位的时间开销。</li>
</ul>
<h3 id="23-堆内存分配策略"><a href="#23-堆内存分配策略" class="headerlink" title="23. 堆内存分配策略"></a>23. 堆内存分配策略</h3><ol>
<li><strong>对象优先在Eden分配</strong>：大多数情况下对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。</li>
<li><strong>大对象直接进入老年代</strong>：大对象容易导致内存明明还有不少空间就提前触发垃圾收集。而当复制大对象时，就意味着高额的内存复制开销。直接将大对象进入老年代的<strong>目的就是为了避免在Eden和Survivor之间来回复制，产生大量的内存复制操作。</strong></li>
<li><strong>长期存活的对象将进入老年代</strong>：对象头中定义了一个对象年龄计数器，每熬过一次Minor GC，年龄计数器加1，默认15时进入老年代。</li>
<li><strong>动态对象年龄判定</strong>：并不是一定要达到age阈值才能进入老年代，如果在Survivor空间中低于或等于某年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</li>
<li><strong>空间分配担保</strong>：发生Minor GC前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么这次Minor GC可以确保是安全的。如果不成立，检查–XX:HandlePromotionFailure参数，看是否允许担保失败，如果允许，继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC；如果小于，或者参数设置的不允许担保失败，那么就要改为进行一次Full GC。</li>
</ol>
<h3 id="24-查看java虚拟机内存占用？"><a href="#24-查看java虚拟机内存占用？" class="headerlink" title="24. 查看java虚拟机内存占用？ "></a>24. 查看java虚拟机内存占用？ <br/></h3><br/> 
<br/> 
<br/>

<h3 id="25-java的类加载流程"><a href="#25-java的类加载流程" class="headerlink" title="25. java的类加载流程"></a>25. java的类加载流程</h3><ol>
<li><p>加载:</p>
<blockquote>
<p>加载阶段是整个类加载过程的一个阶段，主要完成三件事：</p>
</blockquote>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流；</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li>
<li>在这个内存中生成一个代表这个类的java.lang.Class对象，作为方法区整个类的各种数据的访问入口。<blockquote>
<p>加载结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区的数据存储格式完全由虚拟机实现自己定义。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>验证：  </p>
<blockquote>
<p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。验证阶段对于虚拟机的类加载机制来说，是一个非常重要，但却不是必须要执行的阶段。</p>
</blockquote>
<ol>
<li><strong>文件格式验证</strong>：第一阶段验证字节流是否符合Class文件格式的规范，并能被当前版本的虚拟机处理。该阶段主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型的要求。包括但不限于：<ul>
<li>是否以魔数0xCAFEBABE开头；</li>
<li>主次版本号是否在当前Java虚拟机接受范围之内；</li>
<li>常量池的常量中是否有不被支持的常量类型；</li>
</ul>
</li>
<li><strong>元数据验证</strong>：第二阶段是对字节码描述的信息进行语义分析，保证其描述的信息是否符合《Java语言规范》的要求。主要目的是对类的元数据信息进行语义校验，保证不存在与java语言规范相悖的元数据信息。<ul>
<li>这个类是否有父类；</li>
<li>父类是否继承了不允许被继承的类；</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法；</li>
</ul>
</li>
<li><strong>字节码验证</strong>：主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li><strong>符号引用验证</strong>：发生在虚拟机将符号引用转化为直接引用的时候。符号引用验证可以看作是对类自身以外的各类信息进行匹配性校验。也就是验证该类是否缺少或者被禁止访问它所依赖的某些外部类、方法、字段等资源。</li>
</ol>
</li>
<li><p>准备：  </p>
<blockquote>
<p>准备阶段是正式为类变量（即静态变量，被static修饰的变量）分配内存并设置<strong>初始值</strong>的阶段。JDK7之前，当HotSpot用永久代实现方法区时，这些类变量使用的内存应在方法区进行分配，方法区本身是一个逻辑上的区域。但JDK7之后，类变量会随着Class对象一起存放在Java堆中。</p>
</blockquote>
<ul>
<li>准备阶段进行的内存分配仅包括类变量，而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在java堆中。</li>
<li>初始值通常是数据类型的零值。但如果类字段的字段属性表中存在ConstantValue属性，也就是该字段被final修饰，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值。</li>
</ul>
</li>
<li><p>解析：</p>
<blockquote>
<p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。常量池中主要存放两大类变量：字面量和符号引用。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。</p>
</blockquote>
<ul>
<li>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。</li>
<li>直接引用：可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局相关，且只能引用加载进虚拟机内存中的内容。</li>
</ul>
</li>
<li><p>初始化</p>
<blockquote>
<p>类加载过程的最后一个步骤。前面几个步骤都由Java虚拟机主导。直到初始化阶段，Java虚拟机才开始真正执行类中编写的Java程序代码，将主导权移交给应用程序。初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程，该方法不是程序员在Java代码中直接编写的代码，而是javac编译器的自动生成物。</p>
</blockquote>
<ul>
<li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有变量的赋值动作和静态语句块中的语句合并产生的。</li>
<li><code>&lt;clinit&gt;()</code>与类的构造函数<code>&lt;init&gt;()</code>方法不同，它不需要显示地调用父类构造器。虚拟机保证子类的<code>&lt;clinit&gt;()</code>方法执行前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。因此在虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法肯定是java.lang.Class。</li>
<li>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，意味着父类中定义的静态语句块优先于子类的变量赋值操作。</li>
<li><code>&lt;clinit&gt;()</code>方法对于类或接口来说不是必须的。如果类中没有静态语句块和对变量的赋值操作，那么编译器就不为这个类生成<code>&lt;clinit&gt;()</code>方法。</li>
<li>接口中不能使用静态语句块，但有变量赋值操作，因此和类一样会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父类的<code>&lt;clinit&gt;()</code>方法，因为只有父类中定义的变量被使用时，父类接口才会被初始化。</li>
<li>如果多个线程同时初始化一个类，那么只会有一个线程去执行<code>&lt;clinit&gt;()</code>方法。其他线程都需要阻塞等待。</li>
</ul>
</li>
</ol>
<h3 id="26-类加载器"><a href="#26-类加载器" class="headerlink" title="26. 类加载器"></a>26. 类加载器</h3><blockquote>
<p>类加载过程中加载阶段的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，实现这个动作的代码被称为“类加载器”。</p>
</blockquote>
<ul>
<li>类与类加载器：类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。因为<strong>对于任何一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间</strong>。</li>
</ul>
<h3 id="27-类加载器的双亲委派"><a href="#27-类加载器的双亲委派" class="headerlink" title="27. 类加载器的双亲委派"></a>27. 类加载器的双亲委派</h3><blockquote>
<p>站在Java虚拟机的角度看，只存在两种类加载器：启动类加载器，c++语言实现，是虚拟机的一部分；和其他所有的类加载器，全都继承自抽象类java.lang.ClassLoader。  </p>
</blockquote>
<blockquote>
<p>站在开发者的角度，自java1.2以来，Java一直保持着三层类加载器、双亲委派的类加载架构。</p>
</blockquote>
<ul>
<li>三层类加载器：  <ol>
<li>启动类加载器：负责加载存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录，或者被<code>-Xbootclasspath</code>参数指定的路径中存放的并且能被java虚拟机识别的类库加载到虚拟机内存中。无法被程序员直接引用。</li>
<li>扩展类加载器： 负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。可直接在程序中使用该加载器。</li>
<li>应用程序类加载器：也被称为“系统类加载器”。负责加载用户路径上所有的类库。如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。可直接使用。</li>
</ol>
</li>
<li>双亲委派模型：</li>
</ul>
<h3 id="28-为什么需要双亲委派"><a href="#28-为什么需要双亲委派" class="headerlink" title="28. 为什么需要双亲委派"></a>28. 为什么需要双亲委派</h3><ul>
<li>使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给Object类在程序的各种类加载器环境中都能够保证是同一个类。</li>
<li>双亲委派模型对于baozhengJava程序的稳定运行极为重要。</li>
</ul>
<h3 id="29-线程上下文类加载器"><a href="#29-线程上下文类加载器" class="headerlink" title="29. 线程上下文类加载器"></a>29. 线程上下文类加载器</h3><br/> 
<br/> 
<br/>

<h3 id="30-对象的创建过程"><a href="#30-对象的创建过程" class="headerlink" title="30. 对象的创建过程"></a>30. 对象的创建过程</h3><ol>
<li>java虚拟机遇到一个new指令时，首先检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查符号引用所代表的类是否已经被加载、解析和初始化过，如果没有，执行类加载过程；</li>
<li>类加载检查通过后，虚拟机将为对象分配内存。对象所需内存的大小在类加载完成时便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从java堆中划分出来。（分配方式有指针碰撞、空闲列表，还要考虑分配内存时并发情况下的线程安全问题：对分配内存动作进行同步处理，或把内存分配的动作按照线程划分在不同空间中进行</li>
<li>内存分配完成后，虚拟机将分配到的内存（除了对象头）都初始化为0，保证对象的实例字段在java代码中不赋初始值就能直接使用。</li>
<li>设置对象头，如是哪个类的实例、如何找到类的元数据信息、GC分代年龄等。</li>
<li>new指令后接着会执行&lt;\init&gt;()方法，按照程序员的意愿对对象进行初始化。</li>
</ol>
<h3 id="31-Class类文件怎么回收"><a href="#31-Class类文件怎么回收" class="headerlink" title="31. Class类文件怎么回收"></a>31. Class类文件怎么回收</h3><br/> 
<br/> 
<br/>

<h3 id="32-Minor-Gc和FULL-Gc的区别"><a href="#32-Minor-Gc和FULL-Gc的区别" class="headerlink" title="32. Minor Gc和FULL Gc的区别"></a>32. Minor Gc和FULL Gc的区别</h3><ol>
<li>部分收集（Partial GC）<ol>
<li>新生代收集Minor GC指目标只是新生代的垃圾收集；</li>
<li>老年代收集（Major GC）指目标指示老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为；</li>
<li>混合收集（Mixed GC）：指目标收集整个新生代和部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li>
</ol>
</li>
<li>整堆收集（FULL GC）：指收集整个Java堆和方法区的垃圾收集；</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Fremont</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">51k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:06</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>

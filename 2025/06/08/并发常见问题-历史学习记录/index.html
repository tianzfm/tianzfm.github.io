<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="1. 什么是线程？ 现代操作系统在运行一个程序时，会为其创建一个进程。 而线程是现代操作系统进行资源调度的基本单元，也叫轻量级进程，在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上告诉切换，让使用者感受到这些线程在同时执行。  2. java线程间通信123451. volatile和synchronized关键字2.">
<meta property="og:type" content="article">
<meta property="og:title" content="并发常见问题-历史学习记录">
<meta property="og:url" content="http://example.com/2025/06/08/%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="有间栈">
<meta property="og:description" content="1. 什么是线程？ 现代操作系统在运行一个程序时，会为其创建一个进程。 而线程是现代操作系统进行资源调度的基本单元，也叫轻量级进程，在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上告诉切换，让使用者感受到这些线程在同时执行。  2. java线程间通信123451. volatile和synchronized关键字2.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/%E9%94%81.png">
<meta property="og:image" content="http://example.com/image/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.jpg">
<meta property="article:published_time" content="2025-06-08T14:38:11.000Z">
<meta property="article:modified_time" content="2025-06-08T14:43:24.111Z">
<meta property="article:author" content="Fremont">
<meta property="article:tag" content="历史学习记录">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/%E9%94%81.png">


<link rel="canonical" href="http://example.com/2025/06/08/%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/06/08/%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","path":"2025/06/08/并发常见问题-历史学习记录/","title":"并发常见问题-历史学习记录"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>并发常见问题-历史学习记录 | 有间栈</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">有间栈</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">1. 什么是线程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-java%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">2.</span> <span class="nav-text">2. java线程间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-number">3.</span> <span class="nav-text">3. 多线程共享数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E4%BA%92%E6%96%A5%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.</span> <span class="nav-text">4. 信号量和互斥量的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84-%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9FWait-%E6%98%AF%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">5. 线程是怎么实现的 线程有哪些方法？Wait()是线程的方法吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 多线程实现的四种方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">6. 线程实现各有什么优缺点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-wait%E5%92%8Csleep%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">7.</span> <span class="nav-text">7. wait和sleep的区别和联系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E8%A6%81%E7%94%A8start-%E6%96%B9%E6%B3%95%E5%8C%BA%E6%89%A7%E8%A1%8Crun-%E6%96%B9%E6%B3%95%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8run-%E6%96%B9%E6%B3%95"><span class="nav-number">8.</span> <span class="nav-text">8. 要用start()方法区执行run()方法而不是直接调用run()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">9.</span> <span class="nav-text">9. 线程有几种状态 上下文切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-ThreadLocal"><span class="nav-number">10.</span> <span class="nav-text">10. ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-ThreadLocal%E7%AE%80%E4%BB%8B"><span class="nav-number">10.1.</span> <span class="nav-text">10.1 ThreadLocal简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-ThreadLocal%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">10.2.</span> <span class="nav-text">10.2 ThreadLocal的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="nav-number">10.3.</span> <span class="nav-text">10.3 ThreadLocal内存泄漏问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81%E5%92%8C%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E4%B8%A4%E8%80%85%E5%8F%AF%E4%BB%A5%E4%BA%92%E7%9B%B8%E5%88%87%E6%8D%A2%E5%90%97"><span class="nav-number">11.</span> <span class="nav-text">11. 就绪状态和阻塞状态有什么区别  两者可以互相切换吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%BC%80%E9%94%80%E5%AF%B9%E6%AF%94"><span class="nav-number">12.</span> <span class="nav-text">12. 进程和线程切换开销对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-Java%E4%B8%AD%E7%9A%84%E9%94%81"><span class="nav-number">13.</span> <span class="nav-text">13. Java中的锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-CAS%E7%9A%84%E5%90%AB%E4%B9%89-ABA%E9%97%AE%E9%A2%98"><span class="nav-number">14.</span> <span class="nav-text">14. CAS的含义 ABA问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">15.</span> <span class="nav-text">15. volatile关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-volatile%E7%AE%80%E4%BB%8B"><span class="nav-number">15.1.</span> <span class="nav-text">15.1 volatile简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">15.2.</span> <span class="nav-text">15.2 并发编程的三个基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-3-volatile%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">15.3.</span> <span class="nav-text">15.3 volatile原理总结：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-4-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">15.4.</span> <span class="nav-text">15.4 synchronized关键字和 volatile 关键字的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">16.</span> <span class="nav-text">16. synchronized关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#16-1-%E5%AF%B9%E4%BA%8Esynchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-number">16.1.</span> <span class="nav-text">16.1. 对于synchronized关键字的了解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-2-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">16.2.</span> <span class="nav-text">16.2. synchronized关键字的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-3-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">16.3.</span> <span class="nav-text">16.3. synchronized关键字的底层原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-4-synchronized%E9%94%81%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%EF%BC%88%E9%94%81%E4%BC%98%E5%8C%96%EF%BC%89"><span class="nav-number">16.4.</span> <span class="nav-text">16.4. synchronized锁状态转换（锁优化）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-5-synchronized%E5%92%8CReentrantLock%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%9A"><span class="nav-number">16.5.</span> <span class="nav-text">16.5. synchronized和ReentrantLock的区别和联系：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-AQS%EF%BC%8C%E5%9F%BA%E4%BA%8EAQS%E5%AE%9E%E7%8E%B0%E7%9A%84lock-CountDownLatch%E3%80%81CyclicBarrier%E3%80%81Semaphore%E4%BB%8B%E7%BB%8D"><span class="nav-number">17.</span> <span class="nav-text">17. AQS，基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#17-1-AQS%E7%AE%80%E4%BB%8B"><span class="nav-number">17.1.</span> <span class="nav-text">17.1 AQS简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-2-AQS%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">17.2.</span> <span class="nav-text">17.2 AQS的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-3-AQS%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90"><span class="nav-number">17.3.</span> <span class="nav-text">17.3 AQS实现分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-4-Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">17.4.</span> <span class="nav-text">17.4 Java中的并发工具类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-5-CyclicBarrier-%E5%92%8C-CountDownLatch-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">18.</span> <span class="nav-text">17.5 CyclicBarrier 和 CountDownLatch 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">19.</span> <span class="nav-text">18. 非公平锁和公平锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-JUC%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">20.</span> <span class="nav-text">19. JUC原子类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#19-1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BAtomic%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">20.1.</span> <span class="nav-text">19.1 介绍一下Atomic原子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-2-JUC%E5%8C%85%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%98%AF%E5%93%AA4%E7%B1%BB"><span class="nav-number">20.2.</span> <span class="nav-text">19.2 JUC包中的原子类是哪4类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-3-AtomicInteger%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">20.3.</span> <span class="nav-text">19.3 AtomicInteger的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-4-AtomicInteger%E7%B1%BB%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">20.4.</span> <span class="nav-text">19.4 AtomicInteger类的原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%AF%BB%EF%BC%8C%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%86%99%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%B8%8D%E7%94%A8%E9%94%81%E5%8F%AF%E4%BB%A5%E5%90%97"><span class="nav-number">21.</span> <span class="nav-text">20. 两个线程读，一个线程写，如何实现，不用锁可以吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%9C%E7%94%A8%E3%80%81%E5%8F%82%E6%95%B0%E3%80%81%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="nav-number">22.</span> <span class="nav-text">21. 线程池作用、参数、有几种</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#21-1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9A"><span class="nav-number">22.1.</span> <span class="nav-text">21.1 线程池的好处：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">23.</span> <span class="nav-text">21.2 线程池的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#21-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-number">23.1.</span> <span class="nav-text">21.3 线程池的任务执行流程：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-Executor"><span class="nav-number">24.</span> <span class="nav-text">22. Executor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#22-1-Executor%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B"><span class="nav-number">24.1.</span> <span class="nav-text">22.1 Executor框架简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-2-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">24.2.</span> <span class="nav-text">22.2 生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-3-ThreadPoolExecutor%E8%AF%A6%E8%A7%A3"><span class="nav-number">24.3.</span> <span class="nav-text">22.3 ThreadPoolExecutor详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-4-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">24.4.</span> <span class="nav-text">22.4 线程池状态转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-Java%E4%B8%AD%E5%A6%82%E4%BD%95%E6%AD%A3%E5%B8%B8%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">25.</span> <span class="nav-text">23. Java中如何正常终止线程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%8A%9B%E5%87%BA%E7%9A%84%E5%BC%82%E5%B8%B8%E5%90%97%EF%BC%9F"><span class="nav-number">26.</span> <span class="nav-text">26. 主线程可以捕获子线程抛出的异常吗？</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fremont</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/08/%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fremont">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="有间栈">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="并发常见问题-历史学习记录 | 有间栈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          并发常见问题-历史学习记录
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-08 22:38:11 / 修改时间：22:43:24" itemprop="dateCreated datePublished" datetime="2025-06-08T22:38:11+08:00">2025-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">历史学习记录</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>54 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="1-什么是线程？"><a href="#1-什么是线程？" class="headerlink" title="1. 什么是线程？"></a>1. 什么是线程？</h2><ol>
<li>现代操作系统在运行一个程序时，会为其创建一个进程。</li>
<li>而线程是现代操作系统进行资源调度的基本单元，也叫轻量级进程，在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上告诉切换，让使用者感受到这些线程在同时执行。</li>
</ol>
<h2 id="2-java线程间通信"><a href="#2-java线程间通信" class="headerlink" title="2. java线程间通信"></a>2. java线程间通信</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. volatile和synchronized关键字</span><br><span class="line">2. 等待/通知机制</span><br><span class="line">3. 管道输入/输出流</span><br><span class="line">4. Thread.join()的使用</span><br><span class="line">5. ThreadLocal的使用</span><br></pre></td></tr></table></figure>
<ol>
<li><p>volatile和synchronized关键字  </p>
<ul>
<li>本质上是通过共享内存的方式实现线程通信：  <ol>
<li>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何堆该变量的访问都需从共享内存中获取，而且对它的改变需要立刻刷新回共享内存。它能保证所有线程对volatile修饰的变量的可见性。</li>
<li>关键字synchronized用来修饰方法或者以同步块的形式使用。它保主要确保在同一个时刻，只能有一个线程处于方法或同步块中，保证了线程对变量访问的可见性和排他性。  <ol>
<li>具体实现本质上是对一个对象的监视器进行获取，而这个获取的过程是排他的，也就是同一个时刻只能有一个线程获取到由synchronized所保护对象的监视器。</li>
<li>任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获得该对象的监视器才能进入同步块或同步方法，而没有获取到监视器的线程将会被阻塞在同步块或同步方法的入口处。</li>
<li>任意线程对Object（Object由synchronized保护）的访问，首先要获得Object的监视器。如果获取失败，线程进入同步队列，线程状态变为BLOCKED。当访问Object的前驱释放了锁，则该释放动作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取。</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li><p>等待&#x2F;通知机制  </p>
<ul>
<li>本质上是生产者和消费者模式，这种模式隔离了做什么和怎么做，在功能层面上实现了解耦。  </li>
<li>等待通知的相关方法是任意Java对象都具备的，因为这些方法被定义在所有对象的超类<code>java.lang.Object</code>上；通过<code>wait()</code>,<code>notify()</code>,<code>notifyAll()</code>来实现。    <ol>
<li>等待&#x2F;通知机制，是指一个线程A调用了对象O的<code>wait()</code>方法进入等待状态，而另一个线程B调用了对象O的<code>notify()</code>或<code>notifyAll()</code>方法，线程A收到通知后从<code>wait()</code>方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互。</li>
<li>调用<code>wait()</code>,<code>notify()</code>,<code>notifyAll()</code>需要注意的细节：  <ol>
<li>使用<code>wait()</code>,<code>notify()</code>,<code>notifyAll()</code>方法前，需要先对调用对象加锁；</li>
<li>调用<code>wait()</code>方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列；</li>
<li><code>notify()</code>和<code>notifyAll()</code>方法调用后，等待线程依旧不会从<code>wait()</code>方法返回，需要调用<code>notify()</code>和<code>notifyAll()</code>的线程释放锁之后，等待线程才有机会从<code>wait()</code>返回；</li>
<li><code>notify()</code>方法将等待队列中的一个线程从等待队列中移到同步队列中，而<code>notifyAll()</code>方法将等待队列中的所有线程全部从等待队列中移到同步队列，被移动的线程状态由WAITING变为BLOCKED;</li>
<li>从<code>wait()</code>方法返回的前提是获得了调用对象的锁；</li>
</ol>
</li>
</ol>
</li>
<li>等待&#x2F;通知机制依托于同步机制，其目的就是确保等待线程从<code>wait()</code>方法返回时能够感知到通知线程对变量做出的修改；</li>
<li><code>WaitThread</code>首先获取了对象的锁，然后调用对象的<code>wait()</code>方法，从而放弃了锁进入了对象的等待队列WaitQueue中，进入等待状态。由于WaitThread释放了对象的锁，NntifyThread随后获取了对象的锁，并调用对象的<code>notify()</code>方法，将WaitThread从WaitQueue移到SynchronizedQueue中，此时WaitThread的状态变为阻塞状态。NotifyThread释放了锁之后，WaitThread再次获取到锁并从<code>wait()</code>方法返回继续执行；</li>
</ul>
</li>
<li><p>管道输入&#x2F;输出流  </p>
<ul>
<li>管道输入&#x2F;输出流和普通文件输入&#x2F;输出流或者网络输入&#x2F;输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存；</li>
<li>管道输入&#x2F;输出流主要包括如下4中具体实现：前两种面向字节，而后两种面向字符。<ol>
<li><code>PipedOutputStream</code>:</li>
<li><code>PipedInputStream</code></li>
<li><code>PipedReader</code></li>
<li><code>PipedWriter</code></li>
</ol>
</li>
<li>对于Piped类型的流，必须要先进行绑定，也就是调用<code>connect()</code>方法，如果没有将输入&#x2F;输出流绑定起来，对于该流的访问将会抛出异常；</li>
</ul>
</li>
<li><p><code>Thread.join()</code>的使用</p>
<ul>
<li>是主线程等待子线程的终止。也就是说主线程的代码块中，如果碰到了<code>t.join()</code>方法，此时主线程需要等待（阻塞），等待子线程结束了(Waits for this thread to die.),才能继续执行<code>t.join()</code>之后的代码块。</li>
</ul>
</li>
<li><p><code>ThreadLocal</code>的使用</p>
<ul>
<li>即线程变量，是一个以Thread对象为键，任意对象为值的存储结构。这个结构被附带在线程上，也就是一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</li>
</ul>
</li>
</ol>
<h2 id="3-多线程共享数据"><a href="#3-多线程共享数据" class="headerlink" title="3. 多线程共享数据"></a>3. 多线程共享数据</h2><ol>
<li>如果每个线程执行的代码相同，可以使用同一个Runnable对象，这个Runnable对象中有那个共享数据，例如，买票系统就可以这么做。 </li>
<li>如果每个线程执行的代码不同，这时候需要用不同的Runnable对象，有如下两种方式来实现这些Runnable对象之间的数据共享： <ul>
<li>将共享数据封装在另外一个对象中，然后将这个对象逐一传递给各个Runnable对象。每个线程对共享数据的操作方法也分配到那个对象身上去完成，这样容易实现针对该数据进行的各个操作的互斥和通信。</li>
<li>将这些Runnable对象作为某一个类中的内部类，共享数据作为这个外部类中的成员变量，每个线程对共享数据的操作方法也分配给外部类，以便实现对共享数据进行的各个操作的互斥和通信，作为内部类的各个Runnable对象调用外部类的这些方法。</li>
</ul>
</li>
</ol>
<h2 id="4-信号量和互斥量的区别"><a href="#4-信号量和互斥量的区别" class="headerlink" title="4. 信号量和互斥量的区别"></a>4. 信号量和互斥量的区别</h2><ol>
<li>互斥用于线程的互斥，信号量用于线程的同步<ul>
<li>这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。</li>
<li>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</li>
<li>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源</li>
</ul>
</li>
<li>互斥量只能是0&#x2F;1，信号量可以是任何非负整数<ul>
<li>一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。</li>
</ul>
</li>
<li>互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</li>
</ol>
<h2 id="5-线程是怎么实现的-线程有哪些方法？Wait-是线程的方法吗？"><a href="#5-线程是怎么实现的-线程有哪些方法？Wait-是线程的方法吗？" class="headerlink" title="5. 线程是怎么实现的 线程有哪些方法？Wait()是线程的方法吗？"></a>5. 线程是怎么实现的 线程有哪些方法？Wait()是线程的方法吗？</h2><h3 id="5-1-多线程实现的四种方法"><a href="#5-1-多线程实现的四种方法" class="headerlink" title="5.1 多线程实现的四种方法"></a>5.1 多线程实现的四种方法</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duanjiapingjy/p/9434244.html">csdn线程实现</a></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 继承`Thread`类，重写run方法（因为Thread本身也实现了Runnable接口）</span><br><span class="line">2. 实现`Runnable`接口，重写`run`方法</span><br><span class="line">3. 实现`Callable`接口，重写call方法（**有返回值**）</span><br><span class="line">4. 使用线程池（**有返回值**）</span><br></pre></td></tr></table></figure>

<ol>
<li>继承<code>Thread</code>类，重写run方法:<ul>
<li>每次新建一个线程，都要新建一个<code>Thread</code>子类的对象；</li>
<li>启动线程，<code>new Thread子类().start()</code>；</li>
<li>创建线程实际上调用的是父类<code>Thread</code>空参的构造器；</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ards[])</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">ExtendsThread</span>().start();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExtendsThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>实现<code>Runnable</code>接口，重写<code>run</code>方法：<ul>
<li>不管创建多少线程，都只需要一个<code>Runnable</code>接口实现类的对象；</li>
<li>启动线程，<code>new Thread(Runnable接口实现类).start()</code>；</li>
<li>创建线程实际上调用的是父类<code>Thread</code>类<code>Runnable</code>类型参数的构造器；</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ards[])</span>&#123;</span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">implRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImplRunnable</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Thread</span>(implRunnable).start();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImplRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span>  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&quot;</span>+ i++);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>实现实现<code>Callable</code>接口，重写call方法<ul>
<li>自定义类实现Callable接口时，必须指定泛型，该泛型即返回值的类型</li>
<li>每次创建一个新的线程，都要创建一个新的Callable接口的实现类、</li>
<li>如何启动线程？<ol>
<li>创建一个Callable接口的实现类的对象</li>
<li>创建一个FutureTask对象，传入Callable类型的参数。<code>public FutureTask(Callable&lt;V&gt; callable)&#123;……&#125;</code></li>
<li>调用Thread类重载的参数为Runnable的构造器创建Thread对象，将FutureTask作为参数传递<ul>
<li><code>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</code></li>
<li><code>public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;</code></li>
</ul>
</li>
</ol>
</li>
<li>如何获取返回值？<ol>
<li>调用FutureTask类的get()方法</li>
</ol>
</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ards[])</span> <span class="keyword">throws</span> InterruptedException, ExecutionException&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">			Callable&lt;Integer&gt; implCallable = <span class="keyword">new</span> <span class="title class_">ImplCallable</span>();</span><br><span class="line">			FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(implCallable);</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;----&quot;</span>+futureTask.get());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImplCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">			result += i;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName());</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>线程池<ul>
<li><code>Executor</code>类</li>
</ul>
</li>
</ol>
<h2 id="6-线程实现各有什么优缺点？"><a href="#6-线程实现各有什么优缺点？" class="headerlink" title="6. 线程实现各有什么优缺点？"></a>6. 线程实现各有什么优缺点？</h2><ol>
<li><p>继承Thread类：</p>
<ul>
<li>Java是单继承， 继承Thread类之后无法再继承其他类</li>
<li>需要为每个需要线程执行的方法单独创建一个class文件，开发效率较低</li>
<li>没有返回值</li>
<li>一般不推荐使用</li>
<li>但编写简单，直接使用<code>this</code>就可以获得当前线程；</li>
</ul>
</li>
<li><p>实现Runnable和Callable接口方式：</p>
<ul>
<li>优点：<ol>
<li>线程类只是实现了Runnable接口（JDK1.0开始）或Callable接口（JDK1.5开始），还可以继承其他类。</li>
<li>多线程可以共享同一个target对象，非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
<li>实现Callable接口创建多线程最大的好处是可以有返回值。</li>
</ol>
</li>
<li>缺点：<ol>
<li>编程稍显复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="7-wait和sleep的区别和联系"><a href="#7-wait和sleep的区别和联系" class="headerlink" title="7. wait和sleep的区别和联系"></a>7. wait和sleep的区别和联系</h2><ol>
<li><code>sleep()</code>没有释放锁，<code>wait()</code>释放锁；</li>
<li>两者都可以暂停线程；</li>
<li><code>wait()</code>方法被用于线程间的通信&#x2F;交互，<code>sleep()</code>方法用于暂停线程；</li>
<li><code>wait()</code>方法被调用后，除非使用<code>wait(long timeout)</code>，超时后线程自动苏醒，否则线程不会自动苏醒，需要别的线程调用同一对象上的<code>notify()</code>或<code>notifyAll()</code>方法。而<code>sleep()</code>方法执行完后，线程会自动苏醒。</li>
</ol>
<h2 id="8-要用start-方法区执行run-方法而不是直接调用run-方法"><a href="#8-要用start-方法区执行run-方法而不是直接调用run-方法" class="headerlink" title="8. 要用start()方法区执行run()方法而不是直接调用run()方法"></a>8. 要用start()方法区执行run()方法而不是直接调用run()方法</h2><blockquote>
<p>new一个Thread会使线程进入新建状态，然后调用线程的<code>start()</code>方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后，就可以开始运行了。<code>start()</code>会执行线程相应的准备工作，然后自动执行<code>run()</code>方法的内容，这是真正的多线程工作。但是，直接执行<code>run()</code>方法，会把<code>run()</code>方法当作<code>main</code>线程下的一个普通方法来执行，并不会在某个线程中执行它，所有这并不是多线程工作。</p>
</blockquote>
<h2 id="9-线程有几种状态-上下文切换"><a href="#9-线程有几种状态-上下文切换" class="headerlink" title="9. 线程有几种状态 上下文切换"></a>9. 线程有几种状态 上下文切换</h2><ol>
<li>NEW：			初始状态，线程被构建，但还没调用<code>start()</code>方法；</li>
<li>RUNNABLE:   		运行状态，Java线程将操作系统中的就绪和运行两种状态统称为“运行状态”；</li>
<li>BLOCKED：  		阻塞状态，标识线程阻塞于锁；</li>
<li>WAITING:     	等待状态，该状态标识线程已经获得锁，但需要当前线程需要等待其他线程做出一些特定动作（如通知或中断）</li>
<li>TIME_WAITING:  	超时等待，可以在指定的时间自行返回；</li>
<li>TERMINATED:      终止状态，表示当前线程已经执行完毕；</li>
</ol>
<ul>
<li><p>总结：  </p>
<ol>
<li>线程创建后，调用<code>start()</code>方法开始运行。</li>
<li>当线程执行<code>wait()</code>方法之后，线程进入等待状态。进入等待状态的线程需要依靠其他现成的通知才能够返回到运行状态；而超时等待状态相当于在等待状态的基础上增加了超时限制，也就是超时时间到达时将会返回到运行状态。</li>
<li>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入阻塞状态；</li>
<li>当线程运行Runnable的<code>run()</code>方法之后将会进入到终止状态。</li>
</ol>
</li>
<li><p>上下文切换：  </p>
<ol>
<li>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载就是一次上下文切换。</li>
</ol>
</li>
<li><p>如何减少上下文的开销：  </p>
<ol>
<li>无锁并发编程；</li>
<li>CAS算法</li>
<li>使用最少线程</li>
<li>协程</li>
</ol>
</li>
</ul>
<h2 id="10-ThreadLocal"><a href="#10-ThreadLocal" class="headerlink" title="10. ThreadLocal"></a>10. ThreadLocal</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fsmly/p/11020641.html">ThreadLocal详解</a> </p>
<h3 id="10-1-ThreadLocal简介"><a href="#10-1-ThreadLocal简介" class="headerlink" title="10.1 ThreadLocal简介"></a>10.1 ThreadLocal简介</h3><blockquote>
<p>多线程访问同一个共享变量的时候容易出现并发问题，特别是多个线程对一个变量进行写入的时候，为了保证线程安全，一般使用者在访问共享变量的时候需要进行额外的同步措施才能保证线程安全性。ThreadLocal是除了加锁这种同步方式之外的一种保证一种规避多线程访问出现线程不安全的方法，当我们在创建一个变量后，如果每个线程对其进行访问的时候访问的都是线程自己的变量这样就不会存在线程不安全问题。<br>ThreadLocal是JDK包提供的，它提供线程本地变量，如果创建一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的一个副本，在实际多线程操作的时候，操作的是自己本地内存中的变量，从而规避了线程安全问题。</p>
</blockquote>
<ol>
<li><code>ThreadLocal</code>，即线程变量，是一个以<code>ThreadLocal</code>对象为键、任意对象为值的存储结构。</li>
<li>这个结构被附带再线程上，也就是说一个线程可以根据一个<code>Thread</code>对象查询到绑定在这个线程上的一个值。</li>
<li>比如可以通过<code>set(T)</code>方法来设置一个值，在当前线程下再通过<code>get()</code>方法获取到原先设置的值。</li>
</ol>
<h3 id="10-2-ThreadLocal的实现原理"><a href="#10-2-ThreadLocal的实现原理" class="headerlink" title="10.2 ThreadLocal的实现原理"></a>10.2 ThreadLocal的实现原理</h3><blockquote>
<p><code>Thread</code>类中有一个<code>threadLocals</code>和<code>inheritableThreadLocals</code>变量，它们都是<code>ThreadLocalMap</code>类型的变量，可以把<code>ThreadLocalMap</code>变量理解成一个为<code>ThreadLocal</code>类实现而定制化的<code>HashMap</code>。默认情况下，每个线程的这两个变量都为<code>null</code>，只有当线程第一次调用<code>ThreadLocal</code>类的<code>set()</code>或<code>get()</code>方法时才会创建他们。</p>
</blockquote>
<ol>
<li><p><code>set()</code>方法源码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">	<span class="comment">//(1)获取当前线程（调用者线程）</span></span><br><span class="line">	<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">	<span class="comment">//(2)以当前线程作为key值，去查找对应的线程变量，找到对应的map</span></span><br><span class="line">	<span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">	<span class="comment">//(3)如果map不为null，就直接添加本地变量，key为当前线程，值为添加的本地变量值</span></span><br><span class="line">	<span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">		map.set(<span class="built_in">this</span>, value);</span><br><span class="line">	<span class="comment">//(4)如果map为null，说明首次添加，需要首先创建出对应的map</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> t.threadLocals; <span class="comment">//获取线程自己的变量threadLocals，并绑定到当前调用线程的成员变量threadLocals上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//createMap方法不仅创建了threadLocals，同时也将要添加的本地变量值添加到了threadLocals中。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">	t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>get()</code>方法源码：</p>
<blockquote>
<p><code>get()</code>方法首先获取当前线程，<code>getMap()</code>方法获取当前线程的<code>ThreadLocal</code>对象，如果不为null，就返回当前线程绑定的本地变量值；否则执行<code>setInitialValue()</code>方法初始化<code>ThreadLocals</code>变量。</p>
</blockquote>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value in the current thread&#x27;s copy of this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment"> * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment"> * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current thread&#x27;s value of this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>remove()</code>方法：</p>
<blockquote>
<p>remove方法判断该当前线程对应的threadLocals变量是否为null，不为null就直接删除当前线程中指定的threadLocals变量</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>) &#123;</span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p><strong>总结</strong>：每个线程内部都有一个<code>threadLocals</code>的成员变量，该变量的类型是<code>ThreadLocal.ThreadLocalMap</code>类型（类似于一个HashMap），其中的<code>key</code>是当前定义的Thread变量的this引用，<code>value</code>是<code>set()</code>方法设置的值。<strong>每个线程的本地变量存放在自己的本地内存变量<code>threadLocals</code>中，如果当前线程一直不消亡，那么这些本地变量就会一直存在，可能导致内存溢出，因此使用完毕需要将其<code>remove</code>掉。</strong></p>
</li>
</ol>
<h3 id="10-3-ThreadLocal内存泄漏问题"><a href="#10-3-ThreadLocal内存泄漏问题" class="headerlink" title="10.3 ThreadLocal内存泄漏问题"></a>10.3 ThreadLocal内存泄漏问题</h3><blockquote>
<p><code>ThreadLocalMap</code>中使用的 <code>key</code>被传递给了<code>WeakReference</code>的构造函数，所以<code>key</code>为 <code>ThreadLocal</code> 的弱引用,而<code>value</code>是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法.  </p>
</blockquote>
<h2 id="11-就绪状态和阻塞状态有什么区别-两者可以互相切换吗"><a href="#11-就绪状态和阻塞状态有什么区别-两者可以互相切换吗" class="headerlink" title="11. 就绪状态和阻塞状态有什么区别  两者可以互相切换吗"></a>11. 就绪状态和阻塞状态有什么区别  两者可以互相切换吗</h2><p>Java中就绪和运行两种状态统称为Runnable状态。  </p>
<p>但在常规线程中（比如操作系统中的线程），就绪状态是指，在线程被创建后，其他线程中调用了该线程的<code>start()</code>方法。就绪状态的线程位于“可运行线程池中”，运行的所有其他条件都满足，只等待获取cpu的使用权（时间片）。也即是，就绪状态的线程除了cpu分配的时间片外，其他的运行所需资源已经全部满足。  </p>
<p>阻塞状态是线程因为某种原因而放弃了cpu的使用权，暂时停止运行。直到线程进入就绪状态，才有机会转换到运行状态。阻塞状态分三种：  </p>
<ol>
<li>等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒，</li>
<li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。</li>
<li>其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I&#x2F;O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入就绪状态。</li>
</ol>
<h2 id="12-进程和线程切换开销对比"><a href="#12-进程和线程切换开销对比" class="headerlink" title="12. 进程和线程切换开销对比"></a>12. 进程和线程切换开销对比</h2><ol>
<li>进程切换开销<ul>
<li>切换虚拟地址空间</li>
<li>切换CPU上下文</li>
<li>切换内核栈</li>
</ul>
</li>
<li>线程切换开销<ul>
<li>切换CPU上下文</li>
<li>切换内核栈</li>
</ul>
</li>
</ol>
<h2 id="13-Java中的锁"><a href="#13-Java中的锁" class="headerlink" title="13. Java中的锁"></a>13. Java中的锁</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jyroy/p/11365935.html">Java锁</a><br><img src="/./image/%E9%94%81.png" alt="锁"></p>
<h2 id="14-CAS的含义-ABA问题"><a href="#14-CAS的含义-ABA问题" class="headerlink" title="14. CAS的含义 ABA问题"></a>14. CAS的含义 ABA问题</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bjweimengshu/article/details/78949435?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160851567016780302998169%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&request_id=160851567016780302998169&biz_id=0">这个人的CAS讲的很好，还有其他博客可以看看</a> </p>
<blockquote>
<p>compare and swap,CAS操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。   </p>
</blockquote>
<ol>
<li>CAS底层是通过<code>unsafe</code>类的<code>compareandSwap</code>方法实现的；<code>compareandSwap</code>有四个参数，分别是要修改的对象、对象中要修改变量的偏移量（可理解为要修改变量的内存地址）、修改之前的旧值、要修改的新值；  </li>
<li>CAS机制包括三个基本操作数：内存地址V、旧的预期值A、要修改的新值B，更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B；  </li>
<li>CAS缺点：<ul>
<li>CPU开销大</li>
<li>不能保证代码块的原子性</li>
<li>ABA问题：<ol>
<li>当一个值从A更新成B，又更新会A，普通CAS机制会误判通过检测。</li>
<li>利用版本号比较可以有效解决ABA问题。<code>AtomicStampedReference</code>类</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="15-volatile关键字"><a href="#15-volatile关键字" class="headerlink" title="15. volatile关键字"></a>15. volatile关键字</h2><h3 id="15-1-volatile简介"><a href="#15-1-volatile简介" class="headerlink" title="15.1 volatile简介"></a>15.1 <code>volatile</code>简介</h3><blockquote>
<p><code>volatile</code>是Java提供的一种轻量级的同步机制，它在<strong>多处理器的开发中</strong>保证了共享变量的可见性。<code>volatile</code>变量修饰符如果使用恰当，回避<code>sychronized</code>更轻量，因为它不会引起线程上下文的切换和调度。<strong><code>volatile</code>的作用主要有两个：实现可见性，禁止指令重排序。</strong></p>
</blockquote>
<h3 id="15-2-并发编程的三个基本概念"><a href="#15-2-并发编程的三个基本概念" class="headerlink" title="15.2 并发编程的三个基本概念"></a>15.2 并发编程的三个基本概念</h3><ol>
<li><strong>原子性</strong>  <ul>
<li>定义：一个操作或多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li>
<li><strong>处理器</strong>如何实现原子操作（解决缓存不一致的问题）：<ol>
<li>总线锁：所谓总线锁就是使用处理器提供的一个<code>LOCK#</code>信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</li>
<li>缓存锁：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</li>
</ol>
</li>
<li><strong>Java</strong>如何实现原子操作：<ol>
<li>锁：<code>volatile</code>可以保证单次操作的原子性，也就是不保证原子性，而<code>synchronized</code>可以保证原子性；</li>
<li>循环CAS</li>
</ol>
</li>
</ul>
</li>
<li><strong>可见性</strong><ul>
<li>定义：当多个线程访问同一变量时，一个线程修改了这个变量的值，其他线程能立即看到这个修改的值。</li>
<li>Java通过提供<code>volatile</code>保证可见性：（汇编指令中多了<code>lock</code>指令，Lock前缀的指令在多核处理器引发下面两件事，从而保证可见性）  <ol>
<li>当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；</li>
<li>这个写操作会导致其他线程中的缓存无效。（通过缓存一致性协议来做到）</li>
</ol>
</li>
<li>总结：底层原理是汇编中的LOCK指令，该指令使得当前处理器缓存行中的数据写回到系统内存，这个写操作通过缓存一致性协议使得其他CPU里缓存的该共享变量的副本无效，要想使用该共享变量，必须重新从主存中读取。从而保证了共享变量的可见性。</li>
</ul>
</li>
<li><strong>有序性</strong><ul>
<li>定义：程序的执行顺序按照代码的先后顺序执行。</li>
<li>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</li>
<li><code>volatile</code>可以保证一定的有序性：  <ol>
<li>当程序执行到<code>volatile</code>变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</li>
<li>在进行指令优化时，不能将在对<code>volatile</code>变量访问的语句放在其后面执行，也不能把<code>volatile</code>变量后面的语句放到其前面执行。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="15-3-volatile原理总结："><a href="#15-3-volatile原理总结：" class="headerlink" title="15.3 volatile原理总结："></a>15.3 <code>volatile</code>原理总结：</h3><p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”<br>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：  </p>
<ol>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li>
</ol>
<h3 id="15-4-synchronized关键字和-volatile-关键字的区别"><a href="#15-4-synchronized关键字和-volatile-关键字的区别" class="headerlink" title="15.4 synchronized关键字和 volatile 关键字的区别"></a>15.4 <code>synchronized</code>关键字和 <code>volatile</code> 关键字的区别</h3><ol>
<li><code>volatile</code>本质上是在告诉JVM缓存中的变量值是不确定的，需要从共享内存中读取；而<code>synchronized</code>是只允许一个线程访问该变量，其他线程被阻塞，直到该线程操作完为止；</li>
<li><code>volatile</code>是在变量级别，而<code>synchronized</code>是在变量、方法和类级别；</li>
<li><code>volatile</code>仅能保证变量的修改可见性，不能保证原子性；而<code>synchronized</code>能保证修改可见性和原子性；</li>
<li><code>volatile</code>不会造成线程阻塞，<code>synchronized</code>可能会造成线程阻塞；</li>
<li><code>volatile</code>不会被编译器优化，<code>synchronized</code>可以被编译器优化；</li>
<li><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而<code>synchronized</code>关键字解决的是多个线程之间访问资源的同步性</strong>；</li>
</ol>
<h2 id="16-synchronized关键字"><a href="#16-synchronized关键字" class="headerlink" title="16. synchronized关键字"></a>16. synchronized关键字</h2><h3 id="16-1-对于synchronized关键字的了解"><a href="#16-1-对于synchronized关键字的了解" class="headerlink" title="16.1. 对于synchronized关键字的了解"></a>16.1. 对于synchronized关键字的了解</h3><p><strong><code>synchronized</code>解决的是多个线程访问资源的同步性，<code>synchronized</code>可以保证被它修饰的方法或代码块在任意时刻只有一个线程执行</strong>；另外在早期的java版本中<code>synchronized</code>属于重量级锁，效率低下。<br>为什么呢？<br>这是因为监视器锁(monitor)是依赖于底层的操作系统的<code>Mutex Lock</code>实现的，Java线程是映射到操作系统的原生线程上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程的切换需要从用户态转换成核心态，这个转换需要相对较长的时间，时间成本比较高。<br>但Java6之后java官方从JVM层面对<code>synchronized</code>较大优化。JDK1.6之后对锁的实现引入大量优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。  </p>
<h3 id="16-2-synchronized关键字的使用"><a href="#16-2-synchronized关键字的使用" class="headerlink" title="16.2. synchronized关键字的使用"></a>16.2. synchronized关键字的使用</h3><ul>
<li>三种方式：   <ol>
<li><strong>修饰实例方法</strong>：作用于当前对象实例加锁，进入同步代码前要获得<strong>当前对象实例的锁</strong></li>
<li><strong>修饰静态方法</strong>：也就是给当前类加锁，会作用类的所有对象实例。要获得当前class的锁</li>
<li><strong>修饰代码块</strong>：指定加锁对象，对给定对象&#x2F;类加锁。<code>synchronized(this|object)</code> 表示进入同步代码库前<strong>要获得给定对象的锁</strong>。<code>synchronized(类.class)</code> 表示进入同步代码前要获得<strong>当前 class 的锁</strong></li>
</ol>
</li>
<li>总结：修饰静态方法和代码块都是给class上锁修饰实例方法是给对象实例上锁；</li>
<li><strong>双重校检锁实现对象单例模式</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="literal">null</span>)</span><br><span class="line">					instance = <span class="keyword">new</span> <span class="title class_">instance</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>instance = new instance()</code>实际上分为三步：  <ol>
<li>为instance分配内存空间</li>
<li>初始化instance</li>
<li>设置instance指向刚分配的内存地址<br>  <strong>所以要用volatile修饰instance，从而禁止jvm的指令重排，防止多线程访问时，由于2 3 重排导致线程访问到一个还没有被初始化的对象；</strong></li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="16-3-synchronized关键字的底层原理"><a href="#16-3-synchronized关键字的底层原理" class="headerlink" title="16.3. synchronized关键字的底层原理"></a>16.3. synchronized关键字的底层原理</h3><p><strong>synchronized关键字底层原理是属于JVM层面的</strong></p>
<ol>
<li><strong>synchronized修饰同步块时</strong>：从java字节码可以看出，synchronized同步语句块是使用<code>monitorenter</code>和<code>monitorexit</code>来实现的，<code>monitorenter</code>指向进入同步代码块的开始位置，<code>monitorexit</code>指向同步代码块的结束位置。当执行<code>monitorenter</code>时，线程试图获取锁也就是<strong>获取对象监视器monitor</strong>的所有权。<ul>
<li>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为0则表示锁可以被获取，获取后将锁的计数器设为1也就是加1；</li>
<li>在执行<code>monitorexit</code>时，将锁计数器设为0，表明锁被释放。</li>
<li>如果获取对象锁失败，当前线程就要被阻塞等待，直到锁被另一个线程释放为止。</li>
</ul>
</li>
<li><strong>synchronized修饰方法时</strong>：修饰方法时没有使用<code>monitorenter</code>和<code>monitorexit</code>指令，而是使用<code>ACC_SYNCHRONIZED</code>标识，该标识指明了该方法是一个同步方法。JVM通过该<code>ACC_SYNCHRONIZED</code>标识来辨别一个方法是否被声明为一个同步方法，从而执行相应的同步调用。</li>
<li>总结：synchronized修饰同步语句块的实现时，使用<code>monitorenter</code>和<code>monitorexit</code>指令，其中<code>monitorenter</code>指令指向同步语句块的开头位置，<code>monitorexit</code>指令指向同步语句块的结束位置；修饰方法时，使用<code>ACC_SYNCHRONIZED</code>标识，该标识指明了该方法是一个同步方法。</li>
</ol>
<h3 id="16-4-synchronized锁状态转换（锁优化）"><a href="#16-4-synchronized锁状态转换（锁优化）" class="headerlink" title="16.4. synchronized锁状态转换（锁优化）"></a>16.4. synchronized锁状态转换（锁优化）</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xdyixia/p/9364247.html">csdn锁优化</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuqinglong/p/9945618.html">Java6及以上版本对synchronized的优化</a><br>JDK1.6之后，对锁的实现引入了大量的优化，如<strong>自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁</strong>等技术来减少锁操作的开销；<br><strong>锁主要存在4种状态：无锁、偏向锁、轻量级锁、重量级锁状态</strong>，他们会随着竞争的激烈而逐渐升级，但不会降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<ol>
<li><p>自旋锁：<br> 线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对于CPU来说是一件很沉重的工作，会给系统的并发性能带来很大压力。但在很多应用上，对象锁的持续状态通常很短，为了这么短的持续时间而频繁的进行阻塞和唤醒线程很不值得，因此<strong>引入了自旋锁</strong>。  </p>
<p> <strong>所谓自旋锁，就是让试图获取锁（该锁已被其他线程获取）的线程等待一段时间，不会被立即阻塞，看持有锁的线程会不会很快释放锁。</strong>   </p>
<p> 怎么等待？<strong>就是执行一段无意义的循环即可（自旋）</strong>   </p>
<p> 但自旋不能替代阻塞，虽然它避免了线程切换的开销，但是也占用了处理器的时间。如果持有锁的线程很快就释放了锁，那自旋的效率就非常好。但如果不是这样，自旋就会白白浪费处理器资源，反而带来性能上的下降。  </p>
<p> 所以自旋的时间（也就是次数）应该有一定的限度，当超过了这个限度之后还是没有获取锁，那么该线程就应当被挂起（也就是阻塞）。  </p>
</li>
<li><p>适应性自旋锁：<br> JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。  </p>
<p> 线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。  </p>
</li>
<li><p>偏向锁：<br> 大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要用CAS操作来加锁和解锁，只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得锁；如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（标识当前是偏向锁）：如果没有设置，使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。   </p>
<p> <strong>偏向锁的撤销：</strong>  </p>
<p> **偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。**偏向锁的撤销，需要等到全局安全点（此时没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。  </p>
</li>
<li><p>轻量级锁：<br> 轻量级锁是由偏向锁升级而来的，一个线程获取偏向锁进入同步块的情况下，若第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；  </p>
<ol>
<li><strong>轻量级锁加锁</strong>：线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，然后将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换成指向锁记录的指针。如果成功，当前线程获得锁；如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。  </li>
<li><strong>轻量级锁解锁</strong>：轻量级锁解锁时，会使用原子得CAS操作将栈帧中的Displaced Mark Word替换到对象头中，如果成功，则说明没有竞争发生，解锁成功；如果失败，则说明当前锁存在竞争，轻量级锁就会膨胀为重量级锁。</li>
</ol>
</li>
<li><p>重量级锁：<br> **因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁得线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。**当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。  </p>
<ol>
<li>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</li>
</ol>
</li>
</ol>
<h3 id="16-5-synchronized和ReentrantLock的区别和联系："><a href="#16-5-synchronized和ReentrantLock的区别和联系：" class="headerlink" title="16.5. synchronized和ReentrantLock的区别和联系："></a>16.5. synchronized和ReentrantLock的区别和联系：</h3><ol>
<li>两者都是可重入锁<blockquote>
<p>可重入锁表示该锁能够支持一个线程对资源的重复加锁。</p>
</blockquote>
</li>
<li>两者都是加锁方式同步，而且都是阻塞式同步。</li>
<li><code>syn</code>操作Mark Word，而<code>lock</code>调用<code>Unsafe</code>的<code>park()</code>方法；</li>
<li><code>synchronized</code>是基于JVM的，而<code>ReentrantLock</code>是基于API的；</li>
<li><code>ReentrantLock</code>比<code>synchronized</code>增加了一些高级功能：<ol>
<li><strong>等待可中断</strong>：<code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。  </li>
<li><strong>可实现公平锁</strong>:<code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li><strong>锁可以绑定多个条件</strong>：<code>ReentrantLock</code>可以同时绑定多个<code>Condition</code>对象，只需多次调用<code>newCondition</code>方法即可。<code>synchronized</code>中，锁对象的<code>wait()</code>和<code>notify()</code>或<code>notifyAll()</code>方法可以实现一个隐含的条件。但如果要和多于一个的条件关联的时候，就不得不额外添加一个锁。</li>
</ol>
</li>
</ol>
<h2 id="17-AQS，基于AQS实现的lock-CountDownLatch、CyclicBarrier、Semaphore介绍"><a href="#17-AQS，基于AQS实现的lock-CountDownLatch、CyclicBarrier、Semaphore介绍" class="headerlink" title="17. AQS，基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore介绍"></a>17. AQS，基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore介绍</h2><h3 id="17-1-AQS简介"><a href="#17-1-AQS简介" class="headerlink" title="17.1 AQS简介"></a>17.1 AQS简介</h3><blockquote>
<p>AQS是一个用来构建锁和或者其他同步器组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队操作。<br>同步器的主要使用方式是继承，<strong>子类通过继承并实现它的抽象方法来管理同步状态</strong>，这时就需要使用同步器提供的三个方法：<code>getState()</code>、<code>setState(int newState)</code>、<code>compareAndSetState(int expect, int update)</code>来进行操作，它们能够保证状态的改变是安全的。<strong>子类推荐被定义为自定义同步组件的静态内部类</strong>，也就是<strong>自定义同步组件implements Lock，然后自定义同步组件里有一个静态内部类，这个静态类extends AQS，并实现获取和释放同步状态的抽象方法。</strong><br>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。  </p>
</blockquote>
<h3 id="17-2-AQS的使用"><a href="#17-2-AQS的使用" class="headerlink" title="17.2 AQS的使用"></a>17.2 AQS的使用</h3><ol>
<li>AQS支持两种同步方式<ul>
<li>独占式</li>
<li>共享式</li>
</ul>
</li>
<li>同步器的设计是基于模板方法模式的，一般的使用方式为：<ol>
<li>使用者继承同步器并重写其指定的方法（重写对共享资源state获取和释放的方法）</li>
<li>将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</li>
</ol>
</li>
<li>重写同步器指定的方法时，需要使用同步器提供的3个方法来访问或修改同步状态：<ol>
<li><code>getState()</code>：获取当前同步状态</li>
<li><code>setState(int newState)</code>：设置当前同步状态</li>
<li><code>compareAndSetState(int expect, int update)</code>：使用CAS设置当前状态，该方法能够保证状态设置的原子性</li>
</ol>
</li>
<li>同步器可重写的方法：<ol>
<li><code>protected boolean tryAcquire(int arg)</code> : 独占式获取同步状态，试着获取，成功返回true，反之为false    </li>
<li><code>protected boolean tryRelease(int arg)</code> ：独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态；</li>
<li><code>protected int tryAcquireShared(int arg)</code> ：共享式获取同步状态，返回值大于等于0，代表获取成功；反之获取失败；</li>
<li><code>protected boolean tryReleaseShared(int arg)</code> ：共享式释放同步状态，成功为true，失败为false</li>
<li><code>protected boolean isHeldExclusively()</code> ： 是否在独占模式下被线程占用。</li>
</ol>
</li>
</ol>
<h3 id="17-3-AQS实现分析"><a href="#17-3-AQS实现分析" class="headerlink" title="17.3 AQS实现分析"></a>17.3 AQS实现分析</h3><ol>
<li><strong>同步队列</strong>：同步器依赖内部的同步队列（一个FIFO的双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点并将其加入同步队列，并阻塞该线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。节点是构成同步队列的基础，同步器有头节点和尾节点的引用。同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。线程若获取同步状态失败，则被构造成节点加入同步队列尾部，这个加入过程通过<code>compareAndSetTail(Node expect, Node update)</code>保证线程安全。</li>
<li><strong>独占式同步状态获取和释放</strong>：在获取同步状态时，同步器维护一个队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋，如果还获取不到就阻塞该线程，而被阻塞线程的唤醒主要靠前驱节点的出队或阻塞线程被中断来实现。移出队列的条件是前驱节点为头节点且该线程获取同步状态成功。在释放同步状态时，同步器调用<code>tryRelease(int arg)</code>方法释放同步状态，然后唤醒头结点的后继节点。</li>
<li><strong>共享式同步状态获取和释放</strong>：与独占式的主要区别在于同一时刻能否有多个线程同时获取到同步状态；<code>tryAcquireShared(int arg)</code>如果返回的值大于0，说明获取同步状态成功。</li>
</ol>
<h3 id="17-4-Java中的并发工具类"><a href="#17-4-Java中的并发工具类" class="headerlink" title="17.4 Java中的并发工具类"></a>17.4 Java中的并发工具类</h3><ol>
<li><code>Semaphore</code>(信号量)-允许多个线程同时访问： <code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</li>
<li><code>CountDownLatch</code> （倒计时器）： <code>CountDownLatch</code> 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li><code>CyclicBarrier</code>(循环栅栏)： <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> <code>类似。CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>
</ol>
<h2 id="17-5-CyclicBarrier-和-CountDownLatch-的区别"><a href="#17-5-CyclicBarrier-和-CountDownLatch-的区别" class="headerlink" title="17.5 CyclicBarrier 和 CountDownLatch 的区别"></a>17.5 CyclicBarrier 和 CountDownLatch 的区别</h2><ol>
<li><code>CountDownLatch</code>的计数器只能使用一次，而<code>CyclicBarrier</code>的计数器可以使用<code>reset()</code>方法重置，所以<code>CyclicBarrier</code>能处理更复杂的业务场景。</li>
<li><code>CyclicBarrier</code>还提供了其他有用的方法，比如<code>getNumberWaiting</code>方法可以获得<code>CyclicBarrier</code>阻塞的线程数量，<code>isBroken()</code>方法用来了解阻塞的线程是否被中断。</li>
</ol>
<h2 id="18-非公平锁和公平锁"><a href="#18-非公平锁和公平锁" class="headerlink" title="18. 非公平锁和公平锁"></a>18. 非公平锁和公平锁</h2><ol>
<li><strong>非公平锁</strong>：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。<ul>
<li>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</li>
<li>缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</li>
</ul>
</li>
<li><strong>公平锁</strong>：多个线程按照申请锁的顺序去获得锁，线程会直接到队列中去排队，永远都是队列的第一位才能得到锁<ul>
<li>优点：所有线程都能得到资源，不会饿死</li>
<li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</li>
</ul>
</li>
</ol>
<h2 id="19-JUC原子类"><a href="#19-JUC原子类" class="headerlink" title="19. JUC原子类"></a>19. JUC原子类</h2><h3 id="19-1-介绍一下Atomic原子类"><a href="#19-1-介绍一下Atomic原子类" class="headerlink" title="19.1 介绍一下Atomic原子类"></a>19.1 介绍一下Atomic原子类</h3><blockquote>
<p>可认为是其操作都是不可分割的类</p>
</blockquote>
<h3 id="19-2-JUC包中的原子类是哪4类"><a href="#19-2-JUC包中的原子类是哪4类" class="headerlink" title="19.2 JUC包中的原子类是哪4类"></a>19.2 JUC包中的原子类是哪4类</h3><ol>
<li>原子更新基本类型类<ol>
<li><code>AtomicInteger</code>：原子更新整型</li>
<li><code>AtomicLong</code>：原子更新长整型</li>
<li><code>AtomicBoolean</code>：原子更新布尔类型</li>
</ol>
</li>
<li>原子更新数组类型类<ol>
<li><code>AtomicIntegerArray</code>：原子更新整型数组里的元素</li>
<li><code>AtomicLongArray</code>：原子更新长整型数组里的元素</li>
<li><code>AtomicReferenceArray</code>：原子更新引用类型数组里的元素</li>
</ol>
</li>
<li>引用类型<ol>
<li><code>AtomicReference</code>：原子更新引用类型</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段</li>
<li><code>AtomicMarkableReference</code>：原子更新带有标记位的引用类型</li>
</ol>
</li>
<li>字段类型（对象的属性修改）<ol>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新整型的字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整型的字段的更新器</li>
<li><code>AtomisStampedReference</code>：原子更新带有版本号的引用类型。<strong>该类将整数值与引用关联起来，可解决CAS进行原子更新时可能出现的ABA问题</strong></li>
</ol>
</li>
</ol>
<h3 id="19-3-AtomicInteger的使用"><a href="#19-3-AtomicInteger的使用" class="headerlink" title="19.3 AtomicInteger的使用"></a>19.3 AtomicInteger的使用</h3><ol>
<li>常用方法 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure></li>
<li>使用实例 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicIntegerTest</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">	<span class="comment">//使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">				count.incrementAndGet();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> count.get();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="19-4-AtomicInteger类的原理"><a href="#19-4-AtomicInteger类的原理" class="headerlink" title="19.4 AtomicInteger类的原理"></a>19.4 AtomicInteger类的原理</h3><blockquote>
<p>AtomicInteger 类主要利用unsafe类实现的CAS机制 + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
</blockquote>
<ol>
<li>读：AtomicInteger本身提供了get()来获取value值，该方法直接返回value变量。因为value变量是volatile类型，这就保证get()读到的是最新值，因为是直接从主内存中读取value 。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;           </span><br><span class="line"><span class="comment">// volatile保证get()读到的是最新值，因为直接从主内存中读取value </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;    <span class="keyword">return</span> value;    &#125;</span><br></pre></td></tr></table></figure></li>
<li>写：这个方法的做法为先获取到当前的 value 属性值，然后将 value 加 1，赋值给一个局部的 next 变量，然而，这两步都是非线程安全的，但是内部有一个死循环，不断去做compareAndSet操作，直到成功为止，也就是修改的根本在compareAndSet方法里面。compareAndSet()方法的代码如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">			<span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">				<span class="keyword">return</span> current;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="20-两个线程读，一个线程写，如何实现，不用锁可以吗"><a href="#20-两个线程读，一个线程写，如何实现，不用锁可以吗" class="headerlink" title="20. 两个线程读，一个线程写，如何实现，不用锁可以吗"></a>20. 两个线程读，一个线程写，如何实现，不用锁可以吗</h2><br>
<br>
<br>    
	  
<h2 id="21-线程池作用、参数、有几种"><a href="#21-线程池作用、参数、有几种" class="headerlink" title="21. 线程池作用、参数、有几种"></a>21. 线程池作用、参数、有几种</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jay-huaxiao/p/11454416.html">csdn线程池</a></p>
<h3 id="21-1-线程池的好处："><a href="#21-1-线程池的好处：" class="headerlink" title="21.1 线程池的好处："></a>21.1 线程池的好处：</h3><ol>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ol>
<h2 id="21-2-线程池的创建"><a href="#21-2-线程池的创建" class="headerlink" title="21.2 线程池的创建"></a>21.2 线程池的创建</h2><p>线程池可以通过<code>ThreadPoolExecutor</code>来创建线程，几个核心参数：  </p>
<ol>
<li><code>corePoolSize</code>：核心线程数最大值，核心线程就算空闲也不会被回收</li>
<li><code>maximumPoolSize</code>：最大线程数</li>
<li><code>keepAliveTime</code>：非核心线程空闲时间保留的最长时间</li>
<li><code>unit</code>：计算上述时间的时间单位</li>
<li><code>workQueue</code>：存放任务的阻塞队列（工作队列）<ol>
<li><code>ArrayBlockingQueue</code>：是一个基于数组结构的<strong>有界</strong>阻塞队列，按FIFO原则对元素排序；</li>
<li><code>LinkedBlockingQueue</code>：基于链表结构的<strong>无界</strong>阻塞队列，按FIFO原则对元素进行排序；吞吐量高于<code>ArrayBlockingQueue</code>;静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列；</li>
<li><code>SynchronousQueue</code>：不存储元素的阻塞队列，每个元素的插入必须要等到另一个元素调用移除操作，否则插入操作一直处于阻塞状态；吞吐量高于<code>LinkedBlockingQueue</code>；静态工厂方法<code>Executors.newCachedThreadPool</code>使用了这个队列。</li>
<li><code>PriorityBlockingQueue</code>：具有优先级的无限阻塞队列</li>
</ol>
</li>
<li><code>threadFactory</code>：创建线程的工厂</li>
<li><code>hanlder</code>：拒绝策略；当线程数目已到达最大线程数且工作队列已满，这时如果还有任务被提交到线程池，线程池需要采用一定的饱和策略，一共4种。 <ol>
<li><code>AbortPolicy</code>    ：        直接抛出异常（默认）</li>
<li><code>DiscardPolicy</code>    ：        直接不处理，丢弃任务</li>
<li><code>DiscardOldestPolicy</code>：    丢弃队列中最老的任务，并执行当前任务</li>
<li><code>CallerRunsPolicy</code>：        交给线程池调用所在的线程进行处理</li>
</ol>
</li>
</ol>
<h3 id="21-3-线程池的任务执行流程："><a href="#21-3-线程池的任务执行流程：" class="headerlink" title="21.3 线程池的任务执行流程："></a>21.3 线程池的任务执行流程：</h3><p>提交一个新任务到线程池中：  </p>
<ol>
<li>若线程池中存活的核心线程数少于<code>corePoolSize</code>，则创建新的核心线程去处理提交的任务。</li>
<li>如果运行的线程数等于或多于<code>corePoolSize</code>，则将任务加入工作队列中。</li>
<li>如果工作队列已满，则创建新的线程处理任务。（创建的是非核心线程，这种线程空闲一定时间后会被回收掉）</li>
<li>如果创建新线程将使当前运行的线程超出<code>maximumPoolSize</code>，任务被拒绝，拒绝策略有四种，由<code>handler</code>参数指定。<blockquote>
<p>总结：当一个新任务提交到线程池中时，优先让核心线程来处理任务，如果当前核心线程数已达到<code>corePoolSize</code>数目，而且都在运行中，就把当前任务加入工作队列中等待；如果工作队列也满了，就创建非核心线程来处理该任务，非核心线程空闲一段时间就会被回收。如果线程池内的线程数已达到最大线程数，不能创建新线程，就只能采用拒绝策略拒绝该任务。</p>
</blockquote>
</li>
</ol>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">核心线程比作公司正式员工</span><br><span class="line">非核心线程比作外包员工</span><br><span class="line">阻塞队列比作需求池</span><br><span class="line">提交任务比作提需求</span><br><span class="line"></span><br><span class="line">当产品提个需求，正式员工（核心线程）先接需求（执行任务）</span><br><span class="line">如果正式员工都有需求在做，即核心线程数已满），产品就把需求先放需求池（阻塞队列）。</span><br><span class="line">如果需求池(阻塞队列)也满了，但是这时候产品继续提需求,怎么办呢？那就请外包（非核心线程）来做。</span><br><span class="line">如果所有员工（最大线程数也满了）都有需求在做了，那就执行拒绝策略。</span><br><span class="line">如果外包员工把需求做完了，它经过一段（keepAliveTime）空闲时间，就离开公司了。</span><br></pre></td></tr></table></figure>

<h2 id="22-Executor"><a href="#22-Executor" class="headerlink" title="22. Executor"></a>22. Executor</h2><h3 id="22-1-Executor框架简介"><a href="#22-1-Executor框架简介" class="headerlink" title="22.1 Executor框架简介"></a>22.1 Executor框架简介</h3><blockquote>
<p>从JDK5开始，把工作单元和执行机制分离开来。工作单元包括<code>Runnable</code>和<code>Callable</code>，而执行机制由<code>Executor</code>框架提供。<br>在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。</p>
</blockquote>
<ul>
<li>Executor框架的结构，主要由三部分：<ol>
<li>任务。实现<code>Runnable</code>或<code>Callable</code>接口的对象。</li>
<li>任务的执行。包括任务执行机制的核心接口<code>Executor</code>，以及继承自<code>Executor</code>的<code>ExecutorService</code>接口。Executor框架有两个关键类实现了<code>ExecutorService</code>接口：<code>ThreadPoolExecutor</code>和<code>ScheduledThreadPoolExecutor</code>。</li>
<li>异步计算的结果。包括接口<code>Future</code>和实现<code>Future</code>接口的<code>FutureTask</code>类。</li>
</ol>
</li>
<li>Executor框架的使用流程：  <ol>
<li>主线程首先要创建<code>Runnable</code>或<code>Callable</code>接口的任务对象。（工具类Executors可以把一个<code>Runnable</code>对象封装为一个<code>Callable</code>对象）</li>
<li>可以把实现<code>Runnable</code>或<code>Callable</code>对象交给<code>ExecutorService</code>执行。（<code>execute()</code>或<code>submit()</code>方法，execute没返回值，submit有返回值）</li>
<li>如果执行的是<code>ExecutorService.submit()</code>，<code>ExecutorService</code>将返回一个实现<code>Future</code>接口的对象（<code>FutureTask</code>对象）。由于<code>FutureTask</code>实现了<code>Runnable</code>，程序员也可以创建<code>FutureTask</code>，然后直接交给<code>ExecutorService</code>执行。</li>
<li>最后，主线程可以执行<code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行<code>FutureTask,cancel(boolean mayInterruptIfRunning)</code>来取消此任务的执行。</li>
</ol>
</li>
<li><code>Executor</code>框架的成员<ol>
<li><code>ThreadPoolExecutor</code><ol>
<li><code>FixedThreadPool</code></li>
<li><code>SingleThreadExecutor</code></li>
<li><code>CachedThreadPool</code></li>
</ol>
</li>
<li><code>ScheduledThreadPoolExecutor</code><ol>
<li><code>ScheduledThreadPoolExecutor</code></li>
<li><code>SingleThreadScheduledExecutor</code></li>
</ol>
</li>
<li><code>Future</code>接口<ol>
<li>实现该接口的<code>FutureTask</code>类</li>
</ol>
</li>
<li><code>Runnable</code>接口</li>
<li><code>Callable</code>接口</li>
<li><code>Executors</code></li>
</ol>
</li>
</ul>
<h3 id="22-2-生命周期"><a href="#22-2-生命周期" class="headerlink" title="22.2 生命周期"></a>22.2 生命周期</h3><blockquote>
<p>ExecutorService 接口继承自 Executor 接口，定义了终止、提交、执行任务、跟踪任务返回结果等方法。  </p>
</blockquote>
<ul>
<li>ExecutorService 的生命周期有三种状态：运行、关闭和已终止。<ol>
<li>execute（Runnable command）：履行 Ruannable 类型的任务,</li>
<li>submit（task）：可用来提交 Callable 或 Runnable 任务，并返回代表此任务的 Future 对象</li>
<li>shutdown（）：在完成已提交的任务后封闭办事，不再接管新任务,</li>
<li>shutdownNow（）：停止所有正在履行的任务并封闭办事。</li>
<li>isTerminated（）：测试是否所有任务都履行完毕了。,</li>
<li>isShutdown（）：测试是否该 ExecutorService 已被关闭</li>
</ol>
</li>
</ul>
<h3 id="22-3-ThreadPoolExecutor详解"><a href="#22-3-ThreadPoolExecutor详解" class="headerlink" title="22.3 ThreadPoolExecutor详解"></a>22.3 ThreadPoolExecutor详解</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">是Executor最核心的类，是线程池的实现类，主要由4个组件构成：</span><br><span class="line">	1. corePool：核心线程池大小</span><br><span class="line">	2. maximumPool：最大线程池大小</span><br><span class="line">	3. BlockingQueue：工作队列</span><br><span class="line">	4. hanlder：拒绝策略</span><br><span class="line"></span><br><span class="line">可以创建3种类型的ThreadPoolExecutor:</span><br><span class="line">	1. FixedThreadPool</span><br><span class="line">	2. SingleThreadExecutor</span><br><span class="line">	3. CachedThreadPool</span><br><span class="line"></span><br><span class="line">面试题：使用无界队列的线程池会导致内存飙升吗？</span><br><span class="line">答案 ：会的，FixedThreadPool和SingleThreadExecutor使用了无界的阻塞队列LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长(比如，上面demo设置了10秒)，会导致队列的任务越积越多，导致机器内存使用不停飙升， 最终导致OOM。</span><br></pre></td></tr></table></figure>
<ol>
<li><code>FixedThreadPool</code><ul>
<li>适用于为了满足资源管理的需求，需要限制当前线程数量的应用场景，比如负载比较重的服务器。</li>
<li>特点：<ol>
<li>核心线程数和最大线程数大小一样</li>
<li>没有所谓的非空闲时间，即keepAliveTime为0</li>
<li>阻塞队列为无界队列LinkedBlockingQueue</li>
</ol>
</li>
<li>工作机制：<ol>
<li>提交任务</li>
<li>如果线程数少于核心线程，创建核心线程执行任务</li>
<li>如果线程数等于核心线程（线程池已经完成预热），把任务添加到LinkedBlockingQueue阻塞队列</li>
<li>如果线程执行完任务，去阻塞队列取任务，继续执行。</li>
</ol>
</li>
</ul>
</li>
<li><code>SingleThreadExecutor</code><ul>
<li>适用于需要保证顺序的执行各个任务；并且在任意时间点，不会有多个线程活动的场景</li>
<li>特点：<ol>
<li>核心线程数为1</li>
<li>最大线程数也为1</li>
<li>阻塞队列是LinkedBlockingQueue</li>
<li>keepAliveTime为0</li>
</ol>
</li>
<li>工作机制：<ol>
<li>提交任务</li>
<li>线程池是否有一条线程在，如果没有，新建线程执行任务</li>
<li>如果有，将任务加到阻塞队列</li>
<li>当前的唯一线程，从队列取任务，执行完一个，再继续取，一个人（一条线程）夜以继日地干活。</li>
</ol>
</li>
</ul>
</li>
<li><code>CachedThreadPool</code><ul>
<li>是大小无界的线程池，是用于执行很多短期异步任务的小程序，或者是负载较轻的服务器。</li>
<li>特点：<ol>
<li>核心线程数为0</li>
<li>最大线程数为Integer.MAX_VALUE</li>
<li>阻塞队列是SynchronousQueue</li>
<li>非核心线程空闲存活时间为60秒<blockquote>
<p>当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。</p>
</blockquote>
</li>
</ol>
</li>
<li>工作机制：<ol>
<li>提交任务</li>
<li>因为没有核心线程，所以任务直接加到SynchronousQueue队列。</li>
<li>判断是否有空闲线程，如果有，就去取出任务执行。</li>
<li>如果没有空闲线程，就新建一个线程执行。</li>
<li>执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="22-4-线程池状态转换"><a href="#22-4-线程池状态转换" class="headerlink" title="22.4 线程池状态转换"></a>22.4 线程池状态转换</h3><p><img src="/./image/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.jpg" alt="线程池状态转换"></p>
<h2 id="23-Java中如何正常终止线程？"><a href="#23-Java中如何正常终止线程？" class="headerlink" title="23. Java中如何正常终止线程？"></a>23. Java中如何正常终止线程？</h2><ol>
<li>使用退出标志，使线程正常退出，也就是当 run() 方法完成后线程中止。</li>
<li>使用 interrupt 方法中断线程。<blockquote>
<p>stop()，suspend() 和 resume()已被弃用</p>
</blockquote>
</li>
</ol>
<h2 id="26-主线程可以捕获子线程抛出的异常吗？"><a href="#26-主线程可以捕获子线程抛出的异常吗？" class="headerlink" title="26. 主线程可以捕获子线程抛出的异常吗？"></a>26. 主线程可以捕获子线程抛出的异常吗？</h2><p>正常情况下，如果不做任何处理，捕获不到。<br>要想捕获，要用ExecutorService。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" rel="tag"># 历史学习记录</a>
              <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"># 并发</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/06/08/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E9%97%AE%E9%A2%98-%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E5%BD%92%E6%A1%A3/" rel="prev" title="股票买卖问题-历史学习记录归档">
                  <i class="fa fa-angle-left"></i> 股票买卖问题-历史学习记录归档
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/06/08/jvm%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" rel="next" title="jvm常见问题-历史学习记录">
                  jvm常见问题-历史学习记录 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Fremont</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">67k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:02</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
